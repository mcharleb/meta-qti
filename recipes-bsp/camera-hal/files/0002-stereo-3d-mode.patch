diff --git a/QCameraHWI.cpp b/QCameraHWI.cpp
index 95e42cb..189ef62 100644
--- a/QCameraHWI.cpp
+++ b/QCameraHWI.cpp
@@ -219,6 +219,10 @@ QCameraHardwareInterface(int cameraId, int mode)
 
     property_get("persist.camera.hal.dis", value, "0");
     mDisEnabled = atoi(value);
+
+    property_get("persist.camera.hal.3d", value, "0");
+    mIs3DModeOn = atoi(value);
+
     /* Open camera stack! */
     result=cam_ops_open(mCameraId, MM_CAMERA_OP_MODE_NOTUSED);
     if (result == MM_CAMERA_OK) {
@@ -1006,7 +1010,11 @@ bool QCameraHardwareInterface::preview_parm_config (cam_ctrl_dimension_t* dim,
         dim->prev_format = value;
     }else if (value == NOT_FOUND){
         //Setting to default Format.
-        dim->prev_format = CAMERA_YUV_420_NV21;
+        if(mIs3DModeOn) {
+            dim->prev_format = CAMERA_YUV_420_NV12;
+        } else {
+           dim->prev_format = CAMERA_YUV_420_NV21;
+        }
     }
     mPreviewFormat = dim->prev_format;
 
@@ -1416,6 +1424,8 @@ int QCameraHardwareInterface::recordingEnabled()
     case QCAMERA_HAL_PREVIEW_STOPPED:
     case QCAMERA_HAL_PREVIEW_START:
     case QCAMERA_HAL_PREVIEW_STARTED:
+        if(mStreamRecord->mActive&&mIs3DModeOn)
+            ret = 1;
         break;
     case QCAMERA_HAL_RECORDING_STARTED:
         ret = 1;
@@ -2342,7 +2352,11 @@ int QCameraHardwareInterface::storeMetaDataInBuffers(int enable)
 {
     /* this is a dummy func now. fix me later */
     mStoreMetaDataInFrame = enable;
-    return 0;
+
+    if(mIs3DModeOn)
+        return -1;
+    else
+        return 0;
 }
 
 status_t QCameraHardwareInterface::sendMappingBuf(int ext_mode, int idx, int fd,
diff --git a/QCameraHWI.h b/QCameraHWI.h
index bc862e5..1fdc367 100644
--- a/QCameraHWI.h
+++ b/QCameraHWI.h
@@ -450,6 +450,7 @@ public:
                                      int *picture_width,
                                      int *picture_height);
     bool isRawSnapshot();
+    bool is3DMode();
     bool mShutterSoundPlayed;
     void dumpFrameToFile(struct msm_frame*, HAL_cam_dump_frm_type_t);
 
@@ -487,6 +488,8 @@ public:
     bool isCameraReady();
     bool isNoDisplayMode();
 
+    mm_camera_ch_data_buf_t mLastPreviewNotifyFrameBuffer;
+
 private:
     int16_t  zoomRatios[MAX_ZOOM_RATIOS];
     struct camera_size_type default_preview_sizes[PREVIEW_TBL_MAX_SIZE];
diff --git a/QCameraHWI_Parm.cpp b/QCameraHWI_Parm.cpp
index d7aa8c8..5db2f87 100755
--- a/QCameraHWI_Parm.cpp
+++ b/QCameraHWI_Parm.cpp
@@ -97,6 +97,9 @@ extern "C" {
 #define DEFAULT_VIDEO_WIDTH 1920
 #define DEFAULT_VIDEO_HEIGHT 1080
 
+#define DEFAULT_PREVIEW_WIDTH_3D 1280
+#define DEFAULT_PREVIEW_HEIGHT_3D 720
+
 #define THUMBNAIL_SIZE_COUNT (sizeof(thumbnail_sizes)/sizeof(thumbnail_size_type))
 #define DEFAULT_THUMBNAIL_SETTING 4
 #define THUMBNAIL_WIDTH_STR "512"
@@ -173,6 +176,21 @@ static camera_size_type default_picture_sizes[] = {
   { 176, 144} // QCIF
 };
 
+static camera_size_type default_3d_picture_sizes[] = {
+  { 1920, 1088}, //HD1080
+  { 1280, 720}, //HD720
+};
+
+static camera_size_type default_preview_sizes_3D[] = {
+  { 1920, 1088}, //1080p
+  { 1280, 720}, // 720P, reserved
+};
+
++static camera_size_type supported_video_sizes_3D[] = {
+  { 1920, 1088},// 1080p
+  { 1280, 720}, // 720p
+};
+#define SUPPORTED_VIDEO_SIZES_3D_COUNT (sizeof(supported_video_sizes_3D)/sizeof(camera_size_type))
 
 static int iso_speed_values[] = {
     0, 1, 100, 200, 400, 800, 1600
@@ -636,12 +654,22 @@ bool QCameraHardwareInterface::getMaxPictureDimension(mm_camera_dimension_t *max
      * array which is smaller than the max dimension.
      * This will be the valid max picture resolution */
     for (unsigned int i = 0; i < mPictureSizeCount; i++) {
-        if ((mPictureSizes[i].width <= dim.width) &&
-            (mPictureSizes[i].height <= dim.height)) {
-            maxDim->height = mPictureSizes[i].height;
-            maxDim->width  = mPictureSizes[i].width;
-            break;
-        }
+
+    	if (mIs3DModeOn) {
+      		if ((mPictureSizes[i].width < dim.width) &&
+          		(mPictureSizes[i].height < dim.height)) {
+          		maxDim->height = mPictureSizes[i].height;
+          		maxDim->width  = mPictureSizes[i].width;
+          		break;
+        	}
+		} else {
+        	if ((mPictureSizes[i].width <= dim.width) &&
+            	(mPictureSizes[i].height <= dim.height)) {
+            	maxDim->height = mPictureSizes[i].height;
+            	maxDim->width  = mPictureSizes[i].width;
+            	break;
+        	}
+		}
     }
     ALOGD("%s: Found Max Picture dimension: %d x %d", __func__,
           maxDim->width, maxDim->height);
@@ -730,14 +758,30 @@ void QCameraHardwareInterface::initDefaultParameters()
     mDimension.video_height    = DEFAULT_VIDEO_HEIGHT;
     // mzhu mDimension.picture_width   = DEFAULT_STREAM_WIDTH;
     // mzhu mDimension.picture_height  = DEFAULT_STREAM_HEIGHT;
-    mDimension.picture_width   = maxDim.width;
-    mDimension.picture_height  = maxDim.height;
+
+	if(mIs3DModeOn) {
+    	mDimension.picture_width   = 1280; //maxDim.width;
+   		mDimension.picture_height  = 720; //maxDim.height;
+	} else {
+    	mDimension.picture_width   = maxDim.width;
+   		mDimension.picture_height  = maxDim.height;
+	}
+
     mDimension.display_width   = DEFAULT_STREAM_WIDTH;
     mDimension.display_height  = DEFAULT_STREAM_HEIGHT;
     mDimension.orig_picture_dx = mDimension.picture_width;
-    mDimension.orig_picture_dy = mDimension.picture_height;
-    mDimension.ui_thumbnail_width = DEFAULT_STREAM_WIDTH;
-    mDimension.ui_thumbnail_height = DEFAULT_STREAM_HEIGHT;
+    mDimension.orig_picture_dy = mDimension.picture_height;a
+
+    //mDimension.ui_thumbnail_width = DEFAULT_STREAM_WIDTH;
+    //mDimension.ui_thumbnail_height = DEFAULT_STREAM_HEIGHT;
+	if(mIs3DModeOn) {
+    	mDimension.ui_thumbnail_width   = 1280; //maxDim.width;
+   		mDimension.ui_thumbnail_height = 720; //maxDim.height;
+	} else {
+    	mDimension.ui_thumbnail_width = maxDim.width;
+   		mDimension.ui_thumbnail_height = maxDim.height;
+	}
+
     mDimension.orig_video_width = DEFAULT_STREAM_WIDTH;
     mDimension.orig_video_height = DEFAULT_STREAM_HEIGHT;
 
@@ -746,10 +790,19 @@ void QCameraHardwareInterface::initDefaultParameters()
     if (mSnapshotFormat == 1) {
       mDimension.main_img_format = CAMERA_YUV_422_NV61;
     } else {
-      mDimension.main_img_format = CAMERA_YUV_420_NV21;
-    }
-    mDimension.thumb_format    = CAMERA_YUV_420_NV21;
-    ALOGV("%s: main_img_format =%d, thumb_format=%d", __func__,
+		if(mIs3DModeOn) {
+      		mDimension.main_img_format = CAMERA_YUV_420_NV12;
+		} else {      		
+			mDimension.main_img_format = CAMERA_YUV_420_NV21;
+		}
+    }
+	if(mIs3DModeOn) {
+    	mDimension.thumb_format    = CAMERA_YUV_420_NV12;
+	} else { 
+    	mDimension.thumb_format    = CAMERA_YUV_420_NV21;
+   	}
+
+	ALOGV("%s: main_img_format =%d, thumb_format=%d", __func__,
          mDimension.main_img_format, mDimension.thumb_format);
     mDimension.prev_padding_format = CAMERA_PAD_TO_WORD;
 
@@ -938,24 +991,45 @@ void QCameraHardwareInterface::initDefaultParameters()
         mParamStringInitialized = true;
     }
 
-    //set supported video sizes
-    mParameters.set(QCameraParameters::KEY_SUPPORTED_VIDEO_SIZES, mVideoSizeValues.string());
-
-    //set default video size to first one in supported table
-    String8 vSize = create_sizes_str(&mVideoSizes[0], 1);
-    mParameters.set(QCameraParameters::KEY_VIDEO_SIZE, vSize.string());
+	if(!mIs3DModeOn) {
+    	//set supported video sizes
+    	mParameters.set(QCameraParameters::KEY_SUPPORTED_VIDEO_SIZES, mVideoSizeValues.string());
+
+    	//set default video size to first one in supported table
+    	String8 vSize = create_sizes_str(&mVideoSizes[0], 1);
+    	mParameters.set(QCameraParameters::KEY_VIDEO_SIZE, vSize.string());
+	} else {
+    	//set supported 3D video sizes
+		String8 videoSizes = create_sizes_str(
+								supported_video_sizes_3D, 
+								SUPPORTED_VIDEO_SIZES_3D_COUNT);    	
+		mParameters.set(QCameraParameters::KEY_SUPPORTED_VIDEO_SIZES, 
+						videoSizes.string());
+
+    	//set default 3D video size to first one in supported table
+    	String8 vSize = create_sizes_str($supported_video_sizes_3D[1], 1);
+    	mParameters.set(QCameraParameters::KEY_VIDEO_SIZE, vSize.string());
+	}
 
     //Set Preview size
-    int default_preview_width, default_preview_height;
-    cam_config_get_parm(mCameraId, MM_CAMERA_PARM_DEFAULT_PREVIEW_WIDTH,
+	if(!mIs3DModeOn) {
+    	int default_preview_width, default_preview_height;
+    	cam_config_get_parm(mCameraId, MM_CAMERA_PARM_DEFAULT_PREVIEW_WIDTH,
             &default_preview_width);
-    cam_config_get_parm(mCameraId, MM_CAMERA_PARM_DEFAULT_PREVIEW_HEIGHT,
+    	cam_config_get_parm(mCameraId, MM_CAMERA_PARM_DEFAULT_PREVIEW_HEIGHT,
             &default_preview_height);
-    mParameters.setPreviewSize(default_preview_width, default_preview_height);
-    mParameters.set(QCameraParameters::KEY_SUPPORTED_PREVIEW_SIZES,
+    	mParameters.setPreviewSize(default_preview_width, default_preview_height);
+    	mParameters.set(QCameraParameters::KEY_SUPPORTED_PREVIEW_SIZES,
+                    mPreviewSizeValues.string());
+    	mDimension.display_width = default_preview_width;
+    	mDimension.display_height = default_preview_height;
+	} else {
+    	mParameters.setPreviewSize(DEFAULT_PREVIEW_WIDTH_3D, DEFAULT_PREVIEW_HEIGHT_3D);
+    	mParameters.set(QCameraParameters::KEY_SUPPORTED_PREVIEW_SIZES,
                     mPreviewSizeValues.string());
-    mDimension.display_width = default_preview_width;
-    mDimension.display_height = default_preview_height;
+    	mDimension.display_width = DEFAULT_PREVIEW_WIDTH_3D;
+    	mDimension.display_height = DEFAULT_PREVIEW_HEIGHT_3D;
+	}
 
     //Set Preview Frame Rate
     if(mFps >= MINIMUM_FPS && mFps <= MAXIMUM_FPS) {
@@ -987,7 +1061,11 @@ void QCameraHardwareInterface::initDefaultParameters()
 
     //Set Preview Format
     //mParameters.setPreviewFormat("yuv420sp"); // informative
-    mParameters.setPreviewFormat(QCameraParameters::PIXEL_FORMAT_YUV420SP);
+    if (mIs3DModeOn) {
+        mParameters.setPreviewFormat(CameraParameters::PIXEL_FORMAT_NV12);
+    } else {
+        mParameters.setPreviewFormat(QCameraParameters::PIXEL_FORMAT_YUV420SP);
+    }
 
     mPreviewFormatValues = create_values_str(
         preview_formats, sizeof(preview_formats) / sizeof(str_map));
@@ -2746,6 +2824,11 @@ status_t QCameraHardwareInterface::setJpegThumbnailSize(const QCameraParameters&
 
     ALOGE("requested jpeg thumbnail size %d x %d", width, height);
 
+	if (mIs3DModeOn) {
+        params.getPreviewSize(&width, &height);
+		ALOGE("3D mode: force thumb size %d x %d", width, height);
+	}
+
     // Validate the picture size
     for (unsigned int i = 0; i < thumbnail_sizes_count; ++i) {
        if (width == default_thumbnail_sizes[i].width
@@ -2767,6 +2850,16 @@ status_t QCameraHardwareInterface::setPictureSize(const QCameraParameters& param
     params.getPictureSize(&width, &height);
     ALOGE("requested picture size %d x %d", width, height);
 
+	if (mIs3DModeOn) {
+		previewWidth = width;
+		previewHeight = height;
+		mParameters.setPreviewSize(previewWidth, previewHeight);
+		mDimension.display_width = previewWidth;
+		mDimension.display_height= previewHeight;
+
+		ALOGE("3D mode: force picture size %d x %d", width, height);
+	}
+
     // Validate the picture size
     for (int i = 0; i < mSupportedPictureSizesCount; ++i) {
         if (width == mPictureSizesPtr[i].width
@@ -2856,6 +2949,11 @@ setNumOfSnapshot(const QCameraParameters& params) {
     return rc;
 }
 
+bool QCameraHardwareInterface::is3DMode()
+{
+  return mIs3DModeOn;
+}
+
 status_t QCameraHardwareInterface::setPreviewFormat(const QCameraParameters& params) {
     const char *str = params.getPreviewFormat();
     int32_t previewFormat = attr_lookup(preview_formats, sizeof(preview_formats) / sizeof(str_map), str);
@@ -3618,9 +3716,17 @@ status_t QCameraHardwareInterface::setPreviewSizeTable(void)
     char str[10] = {0};
 
     /* Initialize table with default values */
-    preview_size_table = default_preview_sizes;
-    preview_table_size = preview_sizes_count;
-
+    //preview_size_table = default_preview_sizes;
+    //preview_table_size = preview_sizes_count;
+    if (!mIs3DModeOn) {
+      preview_size_table = default_preview_sizes;
+      preview_table_size = sizeof(default_preview_sizes)/
+          sizeof(default_preview_sizes[0]);
+    } else {
+      preview_size_table = default_preview_sizes_3D;
+      preview_table_size = sizeof(default_preview_sizes_3D)/
+        sizeof(default_preview_sizes_3D[0]);
+    }
 
     /* Get maximum preview size supported by sensor*/
     memset(&dim, 0, sizeof(mm_camera_dimension_t));
@@ -3636,6 +3742,16 @@ status_t QCameraHardwareInterface::setPreviewSizeTable(void)
          dim.width, dim.height);
 
     for (i = 0; i < preview_table_size; i++) {
+      if (mIs3DModeOn) {
+        if ((preview_size_table->width < dim.width) &&
+          (preview_size_table->height < dim.height)) {
+          ALOGD("%s: Camera Preview Size Table "
+               "Max width: %d height %d table_size: %d",
+               __func__, preview_size_table->width,
+               preview_size_table->height, preview_table_size - i);
+          break;
+        }
+      } else {
         if ((preview_size_table->width <= dim.width) &&
             (preview_size_table->height <= dim.height)) {
             ALOGD("%s: Camera Preview Size Table "
@@ -3644,8 +3760,9 @@ status_t QCameraHardwareInterface::setPreviewSizeTable(void)
                  preview_size_table->height, preview_table_size - i);
             break;
         }
+	  } // end 3D mode
         preview_size_table++;
-    }
+    } // end for
     //set preferred preview size to maximum preview size
     sprintf(str, "%dx%d", preview_size_table->width, preview_size_table->height);
     mParameters.set(QCameraParameters::KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO, str);
@@ -3668,9 +3785,20 @@ status_t QCameraHardwareInterface::setPictureSizeTable(void)
     int i = 0, count = 0;
 
     /* Initialize table with default values */
-    picture_table_size = sizeof(default_picture_sizes)/
+    /*picture_table_size = sizeof(default_picture_sizes)/
         sizeof(default_picture_sizes[0]);
-    picture_size_table = default_picture_sizes;
+    picture_size_table = default_picture_sizes;*/
+
+    if (mIs3DModeOn) {
+      picture_table_size = sizeof(default_3d_picture_sizes)/
+        sizeof(default_3d_picture_sizes[0]);
+      picture_size_table = default_3d_picture_sizes;
+    } else {
+      picture_table_size = sizeof(default_picture_sizes)/
+          sizeof(default_picture_sizes[0]);
+      picture_size_table = default_picture_sizes;
+    }
+
     mPictureSizes =
         ( struct camera_size_type *)malloc(picture_table_size *
                                            sizeof(struct camera_size_type));
@@ -3698,6 +3826,18 @@ status_t QCameraHardwareInterface::setPictureSizeTable(void)
     for (i = 0; i < picture_table_size; i++) {
         /* We'll store those dimensions whose width AND height
            are less than or equal to maximum supported */
+      if (mIs3DModeOn) {
+        if ((picture_size_table->width < dim.width) &&
+          (picture_size_table->height < dim.height)) {
+          ALOGD("%s: Camera Picture Size Table "
+               "Max width: %d height %d table_size: %d",
+               __func__, picture_size_table->width,
+               picture_size_table->height, count+1);
+          mPictureSizes[count].height = picture_size_table->height;
+          mPictureSizes[count].width = picture_size_table->width;
+          count++;
+        }
+      } else {
         if ((picture_size_table->width <= dim.width) &&
             (picture_size_table->height <= dim.height)) {
             ALOGD("%s: Camera Picture Size Table "
@@ -3708,8 +3848,9 @@ status_t QCameraHardwareInterface::setPictureSizeTable(void)
             mPictureSizes[count].width = picture_size_table->width;
             count++;
         }
+	  } // end 3D mode
         picture_size_table++;
-    }
+    } // end for
     mPictureSizeCount = count;
 
 end:
diff --git a/QCameraHWI_Preview.cpp b/QCameraHWI_Preview.cpp
index df9d8ab..6e99b59 100644
--- a/QCameraHWI_Preview.cpp
+++ b/QCameraHWI_Preview.cpp
@@ -87,6 +87,10 @@ status_t QCameraStream_preview::getBufferFromSurface() {
     ret = cam_config_get_parm(mCameraId, MM_CAMERA_PARM_DIMENSION,&dim);
 
 	format = mHalCamCtrl->getPreviewFormatInfo().Hal_format;
+    if(mHalCamCtrl->mIs3DModeOn){
+        format |= HAL_3D_OUT_SIDE_BY_SIDE|HAL_3D_IN_SIDE_BY_SIDE_L_R;
+    }
+
 	if(ret != NO_ERROR) {
         ALOGE("%s: display format %d is not supported", __func__, dim.prev_format);
     goto end;
@@ -842,6 +846,7 @@ status_t QCameraStream_preview::processPreviewFrameWithDisplay(
 
   mHalCamCtrl->mPreviewMemoryLock.lock();
   mNotifyBuffer[frame->def.idx] = *frame;
+  mHalCamCtrl->mLastPreviewNotifyFrameBuffer = *frame;
 
   ALOGI("Enqueue buf handle %p\n",
   mHalCamCtrl->mPreviewMemory.buffer_handle[frame->def.idx]);
@@ -1059,6 +1064,7 @@ status_t QCameraStream_preview::processPreviewFrameWithOutDisplay(
 
   mHalCamCtrl->mPreviewMemoryLock.lock();
   mNotifyBuffer[frame->def.idx] = *frame;
+  mHalCamCtrl->mLastPreviewNotifyFrameBuffer = *frame;
 
   /* Save the last displayed frame. We'll be using it to fill the gap between
      when preview stops and postview start during snapshot.*/
diff --git a/QCameraHWI_Record.cpp b/QCameraHWI_Record.cpp
index e41412f..f8330fe 100755
--- a/QCameraHWI_Record.cpp
+++ b/QCameraHWI_Record.cpp
@@ -153,6 +153,8 @@ status_t QCameraStream_record::start()
   status_t ret = NO_ERROR;
   ALOGV("%s: BEGIN", __func__);
 
+  if(!mHalCamCtrl->mIs3DModeOn) {
+
   Mutex::Autolock lock(mStopCallbackLock);
   if(!mInit) {
     ALOGE("%s ERROR: Record buffer not registered",__func__);
@@ -193,6 +195,9 @@ status_t QCameraStream_record::start()
     ALOGE("%s : Video streaming Started",__func__);
     ret = NO_ERROR;
   }
+
+  } /* non-3DMode */
+
   mActive = true;
   ALOGV("%s: END", __func__);
   return ret;
@@ -248,6 +253,9 @@ void QCameraStream_record::stop()
     return;
   }
   mActive =  false;
+
+  if(!mHalCamCtrl->mIs3DModeOn) {
+
   Mutex::Autolock lock(mStopCallbackLock);
 #if 0 //mzhu, when stop recording, all frame will be dirty. no need to queue frame back to kernel any more
   mRecordFreeQueueLock.lock();
@@ -283,6 +291,8 @@ void QCameraStream_record::stop()
 
   releaseEncodeBuffer();
 
+  } /* non-3D mode */
+
   mActive = false;
   ALOGV("%s: END", __func__);
 
@@ -410,7 +420,7 @@ status_t QCameraStream_record::initEncodeBuffers()
   frame_len = dim.video_frame_offset.frame_len;
 
   buf_cnt = VIDEO_BUFFER_COUNT;
-  if(mHalCamCtrl->isLowPowerCamcorder()) {
+  if(mHalCamCtrl->isLowPowerCamcorder() & 0) {
     ALOGE("%s: lower power camcorder selected", __func__);
     buf_cnt = VIDEO_BUFFER_COUNT_LOW_POWER_CAMCORDER;
   }
@@ -526,6 +536,9 @@ void QCameraStream_record::releaseRecordingFrame(const void *opaque)
         ALOGE("%s : Recording already stopped!!! Leak???",__func__);
         return;
     }
+
+	if(!mHalCamCtrl->mIs3DModeOn) {
+
     for(int cnt = 0; cnt < mHalCamCtrl->mRecordingMemory.buffer_count; cnt++) {
       if (mHalCamCtrl->mStoreMetaDataInFrame) {
         if(mHalCamCtrl->mRecordingMemory.metadata_memory[cnt] &&
@@ -547,6 +560,9 @@ void QCameraStream_record::releaseRecordingFrame(const void *opaque)
         }
       }
     }
+
+	} /* non-3d mode */
+
 	ALOGE("%s: cannot find the matched frame with opaue = 0x%p", __func__, opaque);
 }
 
diff --git a/QCameraHWI_Still.cpp b/QCameraHWI_Still.cpp
index dc827a3..6a71f7a 100755
--- a/QCameraHWI_Still.cpp
+++ b/QCameraHWI_Still.cpp
@@ -1005,6 +1005,9 @@ static void *snapshot_thread(void *obj)
     QCameraStream_Snapshot *pme = (QCameraStream_Snapshot *)obj;
     ALOGD("%s: E", __func__);
     if (pme != 0) {
+        if(pme->mHalCamCtrl->is3DMode()) {
+            pme->receiveRawPicture(&pme->mHalCamCtrl->mLastPreviewNotifyFrameBuffer);
+        }
         pme->runSnapshotThread(obj);
     }
     else ALOGW("not starting snapshot thread: the object went away!");
@@ -1290,6 +1293,9 @@ takePictureJPEG(void)
 
     /* Take snapshot */
     ALOGD("%s: Call MM_CAMERA_OPS_SNAPSHOT", __func__);
+
+    if(!mHalCamCtrl->is3DMode()) {
+
     if (NO_ERROR != cam_ops_action(mCameraId,
                                               TRUE,
                                               MM_CAMERA_OPS_SNAPSHOT,
@@ -1298,7 +1304,7 @@ takePictureJPEG(void)
            ret = FAILED_TRANSACTION;
            goto end;
     }
-
+    } /* non-3d mode */
     /* TBD: Temp: to be removed once event callback
        is implemented in mm-camera lib  */
     pthread_attr_t attr;
@@ -2298,6 +2304,12 @@ status_t QCameraStream_Snapshot::start(void) {
     mSnapshotDataCallingBack = 0;
     mFreeSnapshotBufAfterDataCb = 0;
 
+
+	if(mHalCamCtrl->is3DMode()) {
+	  LOGE("%s: 3D snapshot start\n", __func__);
+	  mHalCamCtrl->dumpFrameToFile(mHalCamCtrl->mLastPreviewNotifyFrameBuffer.def.frame, HAL_DUMP_FRM_PREVIEW);
+	}
+
     /* Keep track of number of snapshots to take - in case of
        multiple snapshot/burst mode */
 
@@ -2390,6 +2402,12 @@ status_t QCameraStream_Snapshot::start(void) {
         goto end;
     }
     else{
+
+      if(mHalCamCtrl->is3DMode()) {
+        //hack mainimage using preview buffer info
+        mHalCamCtrl->mLastPreviewNotifyFrameBuffer.snapshot.main = mHalCamCtrl->mLastPreviewNotifyFrameBuffer.def;
+        mHalCamCtrl->mLastPreviewNotifyFrameBuffer.snapshot.thumbnail = mHalCamCtrl->mLastPreviewNotifyFrameBuffer.def;
+      }
         ret = takePictureJPEG();
         goto end;
     }
@@ -2410,6 +2428,8 @@ void QCameraStream_Snapshot::stopPolling(void)
 {
     mm_camera_ops_type_t ops_type;
 
+	if(!mHalCamCtrl->is3DMode()) {
+
     if (mSnapshotFormat == PICTURE_FORMAT_JPEG) {
         ops_type = isZSLMode() ? MM_CAMERA_OPS_ZSL : MM_CAMERA_OPS_SNAPSHOT;
     }else
@@ -2419,6 +2439,7 @@ void QCameraStream_Snapshot::stopPolling(void)
                                           ops_type, this)) {
         ALOGE("%s: Failure stopping snapshot", __func__);
     }
+	} /* Non-3D mode */
 }
 
 void QCameraStream_Snapshot::stop(void)
diff --git a/mm-camera-interface/mm_camera.c b/mm-camera-interface/mm_camera.c
index 20dff11..134f03c 100755
--- a/mm-camera-interface/mm_camera.c
+++ b/mm-camera-interface/mm_camera.c
@@ -981,7 +981,8 @@ int32_t mm_camera_open(mm_camera_obj_t *my_obj,
     int32_t rc = MM_CAMERA_OK;
     int8_t n_try=MM_CAMERA_DEV_OPEN_TRIES;
     uint8_t sleep_msec=MM_CAMERA_DEV_OPEN_RETRY_SLEEP;
-    uint8_t i;
+    uint8_t i = 0;
+    uint8_t is_3d_enabled = 0;
 
 	CDBG("%s:  begin\n", __func__);
 
@@ -1082,6 +1083,19 @@ int32_t mm_camera_open(mm_camera_obj_t *my_obj,
         return -MM_CAMERA_E_GENERAL;
     }
 
+    /* ToDo: Add the check if APP has set the 3D mode or not. For now just
+     *       just set 3D mode always.
+     */
+    if(my_obj->properties.modes & CAMERA_MODE_3D) {
+        is_3d_enabled = 1;
+        rc = mm_camera_send_native_ctrl_cmd(my_obj, CAMERA_ENABLE_STEREO_CAM,
+              sizeof(is_3d_enabled), (void *)&is_3d_enabled);
+        if (rc != MM_CAMERA_OK) {
+            CDBG_ERROR("%s: CAMERA_ENABLE_STEREO_CAM failed\n", __func__);
+            return -MM_CAMERA_E_GENERAL;
+        }
+     }
+
     mm_camera_poll_threads_init(my_obj);
     mm_camera_init_ch_stream_count(my_obj);
     CDBG("%s : Launch Threads in Cam Open",__func__);
diff --git a/mm-camera-interface/mm_camera_interface2.c b/mm-camera-interface/mm_camera_interface2.c
index 2b35e3b..7ef4dc6 100755
--- a/mm-camera-interface/mm_camera_interface2.c
+++ b/mm-camera-interface/mm_camera_interface2.c
@@ -668,7 +668,7 @@ extern mm_camera_t * mm_camera_query (uint8_t *num_cameras)
           camera_info.modes_supported |= CAMERA_MODE_3D;
 
       g_cam_ctrl.camera[*num_cameras].camera_info.position =
-        (cam_type == 1) ? FRONT_CAMERA : BACK_CAMERA;
+        (cam_type == 1 || cam_type == 4) ? FRONT_CAMERA : BACK_CAMERA;
       g_cam_ctrl.camera[*num_cameras].camera_info.sensor_mount_angle =
           mount_angle;
       g_cam_ctrl.camera[*num_cameras].sensor_type = 0;
