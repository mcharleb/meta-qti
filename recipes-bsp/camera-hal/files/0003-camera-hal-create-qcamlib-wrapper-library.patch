From e003f0f820b4f8991ae378427f62f5ebb7070099 Mon Sep 17 00:00:00 2001
From: Punit Soni <punits@qti.qualcomm.com>
Date: Tue, 28 Apr 2015 13:44:39 -0700
Subject: [PATCH] camera-hal: create qcamlib wrapper library

Add a camera api interface to expose basic camera functionality
This is a wrapper on mm-camera-interface library, which takes
care of complex process of camera initialization.

Change-Id: I92435bab07ecbde1fd45796a9a7f04ff6e85fdb6
---
 Makefile.am                                        |   1 +
 QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h |   2 +-
 .../stack/mm-camera-test/src/mm_qcamera_preview.c  |   8 +-
 configure.ac                                       |   7 +-
 qcamlib/Makefile.am                                |  52 +++++++
 qcamlib/inc/qcamlib.h                              | 100 ++++++++++++
 qcamlib/src/qcam_log.h                             |  25 +++
 qcamlib/src/qcamlib.c                              | 124 +++++++++++++++
 qcamlib/test/qcamlib_test.c                        | 169 +++++++++++++++++++++
 9 files changed, 480 insertions(+), 8 deletions(-)
 mode change 100755 => 100644 Makefile.am
 mode change 100755 => 100644 QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
 mode change 100755 => 100644 QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
 mode change 100755 => 100644 configure.ac
 create mode 100644 qcamlib/Makefile.am
 create mode 100755 qcamlib/inc/qcamlib.h
 create mode 100644 qcamlib/src/qcam_log.h
 create mode 100755 qcamlib/src/qcamlib.c
 create mode 100755 qcamlib/test/qcamlib_test.c

diff --git a/Makefile.am b/Makefile.am
old mode 100755
new mode 100644
index 1980fbf..b8916fb
--- a/Makefile.am
+++ b/Makefile.am
@@ -3,6 +3,7 @@ ACLOCAL_AMFLAGS = -I m4
 dirs =
 dirs += mm-image-codec
 dirs += QCamera2/stack
+dirs += qcamlib
 
 SUBDIRS = $(dirs)
 
diff --git a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
old mode 100755
new mode 100644
index 07ff9cd..d38c1b7
--- a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
+++ b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
@@ -70,6 +70,6 @@
   #define CDBG_ERROR(fmt, args...) fprintf(stderr, fmt"\n", ##args)
 #endif
 
-#define DUMP_PRV_IN_FILE 1
+#define DUMP_PRV_IN_FILE 0
 
 #endif /* __MM_QCAMERA_DBG_H__ */
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
old mode 100755
new mode 100644
index d83b8a1..b6c1401
--- a/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
@@ -36,7 +36,7 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifdef DUMP_PRV_IN_FILE
 	#define FRAME_MOD 30
 	#define MAX_NUM_FRAME_DUMP  (FRAME_MOD * 100)
-#endif 
+#endif
 
 static void mm_app_metadata_notify_cb(mm_camera_super_buf_t *bufs,
                                      void *user_data)
@@ -106,8 +106,8 @@ static void mm_app_preview_notify_cb(mm_camera_super_buf_t *bufs,
 {
 
 #ifdef DUMP_PRV_IN_FILE
-    static int frame_count=0; 
-#endif 
+    static int frame_count=0;
+#endif
 	  int i = 0;
     mm_camera_channel_t *channel = NULL;
     mm_camera_stream_t *p_stream = NULL;
@@ -147,7 +147,7 @@ static void mm_app_preview_notify_cb(mm_camera_super_buf_t *bufs,
     if ( 0 < pme->fb_fd ) {
         mm_app_overlay_display(pme, frame->fd);
     }
-#ifdef DUMP_PRV_IN_FILE
+#if DUMP_PRV_IN_FILE
 	if ( (frame_count < MAX_NUM_FRAME_DUMP ) &&  (frame_count % FRAME_MOD == 0) )
 	{
 		    char file_name[64];
diff --git a/configure.ac b/configure.ac
old mode 100755
new mode 100644
index 247598c..a3d185a
--- a/configure.ac
+++ b/configure.ac
@@ -63,13 +63,13 @@ else
 	BUILD_JPEG=false
 fi
 
-AC_ARG_WITH([dlog],	
+AC_ARG_WITH([dlog],
       AC_HELP_STRING([--with-dlog],
          [enable dlog, building HLOS systems which use dlog]))
 
 if (test "x${with_dlog}" = "xyes"); then
       AC_DEFINE(ENABLE_USEDLOG, 1, [Define if HLOS systems uses dlog])
-      PKG_CHECK_MODULES(DLOG, [dlog])	
+      PKG_CHECK_MODULES(DLOG, [dlog])
       AC_SUBST(DLOG_CFLAGS)
       AC_SUBST(DLOG_LIBS)
 fi
@@ -97,6 +97,7 @@ AC_OUTPUT([ \
   QCamera2/stack/mm-camera-interface/Makefile \
   QCamera2/stack/mm-jpeg-interface/Makefile \
   QCamera2/stack/mm-camera-test/Makefile \
-  mm-image-codec/Makefile
+  mm-image-codec/Makefile \
+  qcamlib/Makefile \
 ])
 
diff --git a/qcamlib/Makefile.am b/qcamlib/Makefile.am
new file mode 100644
index 0000000..ada11e8
--- /dev/null
+++ b/qcamlib/Makefile.am
@@ -0,0 +1,52 @@
+ACLOCAL_AMFLAGS = -I m4
+
+## build libqcam.so ##
+lib_LTLIBRARIES = libqcam.la
+
+libqcam_la_CFLAGS = -fPIC
+libqcam_la_CFLAGS += -g -O0
+
+libqcam_la_CFLAGS += -DCAMERA_ION_HEAP_ID=ION_IOMMU_HEAP_ID
+libqcam_la_CFLAGS += -DCAMERA_GRALLOC_HEAP_ID=GRALLOC_USAGE_PRIVATE_IOMMU_HEAP
+libqcam_la_CFLAGS += -DCAMERA_GRALLOC_FALLBACK_HEAP_ID=GRALLOC_USAGE_PRIVATE_IOMMU_HEAP
+libqcam_la_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
+libqcam_la_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
+libqcam_la_CFLAGS += -DNUM_RECORDING_BUFFERS=9
+
+
+libqcam_la_CFLAGS += -I src
+libqcam_la_CFLAGS += -I inc
+libqcam_la_CFLAGS += -I ../QCamera2/stack/common
+libqcam_la_CFLAGS += -I ../
+libqcam_la_CFLAGS += -I ../mm-image-codec/qexif
+libqcam_la_CFLAGS += -I ../mm-image-codec/qomx_core
+libqcam_la_CFLAGS += -I ../android-includes
+libqcam_la_CFLAGS += -I ../QCamera2/stack/mm-camera-interface/inc
+libqcam_la_CFLAGS += -I ../QCamera2/stack/mm-camera-test/inc
+
+libqcam_la_SOURCES = src/qcamlib.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_socket.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_commands.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_reprocess.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_snapshot.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_queue.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_unit_test.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
+libqcam_la_SOURCES += ../QCamera2/stack/mm-camera-test/src/mm_qcamera_rdi.c
+
+libqcam_la_LDFLAGS = -shared
+libqcam_la_LIBADD = -ldl -lrt
+libqcam_la_LIBADD += ../QCamera2/stack/mm-camera-interface/libmmcamera_interface.la
+
+## build qcamlib-test ##
+
+bin_PROGRAMS = qcamlib-test
+
+qcamlib_test_CFLAGS = -I inc
+qcamlib_test_CFLAGS += -g
+
+qcamlib_test_SOURCES = test/qcamlib_test.c
+
+qcamlib_test_LDADD = libqcam.la
diff --git a/qcamlib/inc/qcamlib.h b/qcamlib/inc/qcamlib.h
new file mode 100755
index 0000000..1c8ce7b
--- /dev/null
+++ b/qcamlib/inc/qcamlib.h
@@ -0,0 +1,100 @@
+/* Copyright (c) 2015 Qualcomm Technologies, Inc.  All Rights Reserved.
+ * Qualcomm Technologies Proprietary and Confidential. */
+
+/**
+ * @file qcamlib.h
+ * @brief Camera API definition header file
+ *
+ */
+
+/**
+ * @mainpage Camera library API documentation
+ *
+ * API usage
+ *
+ * @code
+ * // call the library functions in following order
+ * qcamlib_init();
+ * qcamlib_register_preview_cb(preview_cb);
+ * qcamlib_start_preview();
+ * qcamlib_stop_preview();
+ * qcamlib_exit();
+ *
+ * // define a callback function to process the preview frames
+ * void preview_cb(void* frame)
+ * {
+ *    // copy frame in user buffer
+ *    qcamlib_copy_preview_frame(buf, frame, buf_size);
+ *    // process the frame
+ *    // Its important to make sure the callback returns in reasonable
+ *    // time to keep up with the required frame rate
+ *    // for 30fps streaming, the callback should return in less than ~33ms
+ * }
+ * @endcode
+ *
+ */
+
+#ifndef __QCAMLIB_H__
+#define __QCAMLIB_H__
+
+#include <stdint.h>
+
+/**
+ * @brief Function pointer type for preview callbacks
+ */
+typedef void (*qcamlib_preview_cb) (void* frame);
+
+/**
+ * @brief Initialize the camera library
+ * @return int
+ *    returns 0 on success, negative value on failure
+ */
+int qcamlib_init(void);
+
+/**
+ * @brief Clean up library resources
+ * @return int
+ *    returns 0 on success, negative value on failure
+ */
+int qcamlib_exit(void);
+
+/**
+ * @brief Start the Preview stream
+ * @return int
+ *    returns 0 on success, negative value on failure
+ */
+int qcamlib_start_preview(void);
+
+/**
+ * @brief Start the Preview stream
+ * @return int
+ *    returns 0 on success, negative value on failure
+ */
+int qcamlib_stop_preview(void);
+
+/**
+ * @brief Register preview callback
+ * @param upcb pointer to the callback function
+ * @return int
+ *    returns 0 on success, negative value on failure
+ */
+int qcamlib_register_preview_cb(qcamlib_preview_cb upcb);
+
+/**
+ * @brief Deregister preview callback
+ * @return int
+ *    returns 0 on success, negative value on failure
+ */
+int qcamlib_deregister_preview_cb(void);
+
+/**
+ * @brief copy preview frame to user buffer
+ * @param buf  user allocated array of size bufsize
+ * @param frame frame handle returned by a preview callback
+ * @param buf_size size of the buf
+ * @return int
+ *    returns 0 on success, negative value on failure
+ */
+int qcamlib_copy_preview_frame(uint8_t *buf, void* frame, uint32_t buf_size);
+
+#endif
diff --git a/qcamlib/src/qcam_log.h b/qcamlib/src/qcam_log.h
new file mode 100644
index 0000000..5efd7a0
--- /dev/null
+++ b/qcamlib/src/qcam_log.h
@@ -0,0 +1,25 @@
+/* Copyright (c) 2015 Qualcomm Technologies, Inc.  All Rights Reserved.
+ * Qualcomm Technologies Proprietary and Confidential. */
+
+#ifndef __QCAM_LOG_H__
+#define __QCAM_LOG_H__
+
+#include <syslog.h>
+
+#define QCAM_ERR(fmt, args...) do { \
+  syslog(LOG_ERR, "%s:%d ERROR: "fmt, __func__, __LINE__, ##args); \
+} while (0)
+
+#define QCAM_DBG(fmt, args...) do { \
+  syslog(LOG_DEBUG, "%s:%d DEBUG: "fmt, __func__, __LINE__, ##args); \
+} while (0)
+
+#define QCAM_DBG_STAMP() do { \
+  QCAM_DBG("reached here"); \
+} while (0)
+
+#define QCAM_INFO(fmt, args...) do { \
+  syslog(LOG_INFO, "%s:%d INFO: "fmt, __func__, __LINE__, ##args); \
+} while (0)
+
+#endif
diff --git a/qcamlib/src/qcamlib.c b/qcamlib/src/qcamlib.c
new file mode 100755
index 0000000..61468e0
--- /dev/null
+++ b/qcamlib/src/qcamlib.c
@@ -0,0 +1,124 @@
+/* Copyright (c) 2015 Qualcomm Technologies, Inc.  All Rights Reserved.
+ * Qualcomm Technologies Proprietary and Confidential. */
+
+#include "mm_qcamera_app.h"
+#include "qcam_log.h"
+#include "qcamlib.h"
+#include <stdbool.h>
+
+static mm_camera_lib_handle g_lib_handle;
+static qcamlib_preview_cb g_upcb = NULL;
+static bool g_previewing = false;
+
+#define PREVIEW_BUF_SIZE (DEFAULT_PREVIEW_WIDTH * DEFAULT_PREVIEW_HEIGHT * 1.5)
+
+int qcamlib_init()
+{
+  int rc;
+
+  rc = mm_camera_lib_open(&g_lib_handle, 0);
+  if (rc != MM_CAMERA_OK) {
+    QCAM_ERR("mm_camera_lib_open() rc=%d", rc);
+    return -1;
+  }
+  return 0;
+}
+
+int qcamlib_exit()
+{
+  if (g_previewing) {
+    QCAM_ERR("preview needs to be stopped before exit");
+    return -1;
+  }
+  mm_camera_lib_close(&g_lib_handle);
+  return 0;
+}
+
+int qcamlib_start_preview()
+{
+  int rc;
+  QCAM_INFO("starting preview");
+  rc = mm_camera_lib_start_stream(&g_lib_handle);
+  if (rc != MM_CAMERA_OK) {
+      QCAM_ERR("mm_camera_lib_start_stream() rc=%d\n", rc);
+      return -1;
+  }
+  g_previewing = true;
+  return 0;
+}
+
+int qcamlib_stop_preview() {
+  int rc;
+  QCAM_INFO("stopping preview");
+  rc = mm_camera_lib_stop_stream(&g_lib_handle);
+  if (rc != MM_CAMERA_OK) {
+      QCAM_ERR("mm_camera_lib_stop_stream() rc=%d\n", rc);
+      return -1;
+  }
+  g_previewing = false;
+  return 0;
+}
+
+void preview_cb_internal(mm_camera_buf_def_t *frame)
+{
+  if (g_upcb) {
+    g_upcb((void*) frame);
+  }
+}
+
+int qcamlib_register_preview_cb(qcamlib_preview_cb upcb)
+{
+  int rc;
+  if (g_previewing) {
+    QCAM_ERR("preview callback needs to be set before starting the preview");
+    return -1;
+  }
+  g_upcb = upcb;
+  prev_callback pcb = (upcb) ? preview_cb_internal : NULL;
+  rc = mm_camera_lib_set_preview_usercb(&g_lib_handle, pcb);
+
+  if (rc != MM_CAMERA_OK) {
+    QCAM_ERR("mm_camera_lib_set_preview_usercb() rc=%d\n", rc);
+    return -1;
+  }
+  return 0;
+}
+
+int qcamlib_deregister_preview_cb()
+{
+  return qcamlib_register_preview_cb(NULL);
+}
+
+int qcamlib_copy_preview_frame(uint8_t *buf, void* frame, uint32_t buf_size)
+{
+  mm_camera_buf_def_t * _frame = (mm_camera_buf_def_t*) frame;
+
+  if (buf_size < PREVIEW_BUF_SIZE) {
+    QCAM_ERR("buf_size=%d, need to be at least %d", buf_size, PREVIEW_BUF_SIZE);
+    return -EINVAL;
+  }
+  if (frame == NULL) {
+    QCAM_ERR("frame NULL");
+    return -EINVAL;
+  }
+  if (buf == NULL) {
+    QCAM_ERR("buf NULL");
+    return -EINVAL;
+  }
+
+  uint32_t offset = 0;
+  int i;
+  for (i=0; i < _frame->num_planes; i++) {
+    memcpy(buf + offset, _frame->buffer + offset, _frame->planes[i].length);
+    offset +=  _frame->planes[i].length;
+  }
+  return 0;
+}
+
+/* get preview frame buffer size */
+uint32_t qcamlib_get_preview_bufsize()
+{
+  /* TODO: returning the default size for now, add logic to calculate size
+     based on current resolution */
+  return PREVIEW_BUF_SIZE;
+}
diff --git a/qcamlib/test/qcamlib_test.c b/qcamlib/test/qcamlib_test.c
new file mode 100755
index 0000000..c98fac1
--- /dev/null
+++ b/qcamlib/test/qcamlib_test.c
@@ -0,0 +1,169 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include "qcamlib.h"
+
+#define DEF_DUMP_COUNT_MAX    100
+#define DEF_DUMP_INTERVAL     30
+#define DEF_OUTPUT_DIR        "camera"
+
+uint32_t frame_count = 0;
+uint32_t dump_count = 0;
+uint32_t dump_count_max = DEF_DUMP_COUNT_MAX;
+uint32_t dump_interval = DEF_DUMP_INTERVAL;
+uint8_t *buf = NULL;
+uint32_t bufsize = 0;
+bool previewing = false;
+
+char *outdir = DEF_OUTPUT_DIR;
+
+char usage_str[] =
+  "usage: qcamlib-test [options]\n"
+  "\n"
+  "    -o outdir\n"
+  "        path where output image files are saved (default=./camera)\n"
+  "    -n dump-count\n"
+  "        maximum number of frames to be saved (default=100)\n"
+  "    -i dump-interval\n"
+  "        save every i'th frame (default=30)\n"
+  "    -h\n"
+  "        print this message\n"
+;
+
+void preview_cb(void* frame)
+{
+  int rc;
+  frame_count++;
+
+  if ((frame_count-1) % dump_interval == 0 && dump_count < dump_count_max) {
+    rc = qcamlib_copy_preview_frame(buf, frame, bufsize);
+    if (rc < 0) {
+      perror("copy frame failed\n");
+      return;
+    }
+    FILE *fp;
+    char filename[128];
+    snprintf(filename, 128, "%s/frame_%d_3840x2160_NV21.yuv",
+             outdir, frame_count);
+    fp = fopen(filename, "w");
+    if (!fp) {
+      perror("fopen() failed\n");
+      return;
+    }
+    rc = fwrite(buf, bufsize, 1, fp);
+    if (rc != 1) {
+      perror("fwrite() failed\n");
+      return;
+    }
+    dump_count++;
+    fclose(fp);
+  }
+}
+
+void print_usage()
+{
+  printf("%s", usage_str);
+  return 0;
+}
+
+int parse_commadline(int argc, char* argv[])
+{
+  int c;
+  while ((c = getopt (argc, argv, "hi:n:o:")) != -1) {
+    switch (c) {
+      case 'o':
+        outdir = optarg;
+        break;
+      case 'i':
+        dump_interval = atoi(optarg);
+        break;
+      case 'n':
+        dump_count_max = atoi(optarg);
+        break;
+      case 'h':
+        print_usage();
+        exit(0);
+      case '?':
+        print_usage();
+        exit(1);
+      default:
+        abort();
+    }
+  }
+}
+
+void print_menu()
+{
+  printf("\nSelect an option\n");
+  printf("\t1. Start preview\n");
+  printf("\t2. Stop preview\n");
+  printf("\t3. Exit\n");
+  printf("\nSelect: ");
+}
+
+int main(int argc, char *argv[])
+{
+
+  parse_commadline(argc, argv);
+
+  printf("---- qcamlib test application ----\n");
+
+  struct stat st = {0};
+  if (stat(outdir, &st) == -1) {
+    mkdir(outdir, 0777);
+  }
+
+  qcamlib_init();
+
+  bufsize = qcamlib_get_preview_bufsize();
+  buf = (uint8_t *) malloc (bufsize);
+
+  if (!buf) {
+    perror("malloc failed\n");
+    qcamlib_exit();
+    goto exit;
+  }
+  qcamlib_register_preview_cb(preview_cb);
+
+  int option;
+  do {
+    print_menu();
+    if (scanf("%d", &option) != 1) {
+      printf("ERROR: use integer options\n");
+      goto exit;
+    }
+    switch (option) {
+      case 1:
+        if (!previewing) {
+          qcamlib_start_preview();
+          previewing = true;
+        }
+        break;
+      case 2:
+        if (previewing) {
+          qcamlib_stop_preview();
+          previewing = false;
+        }
+        break;
+      case 3:
+        if (previewing) {
+          qcamlib_stop_preview();
+          previewing = false;
+        }
+        goto exit;
+      default:
+        printf("invalid option\n");
+        continue;
+    }
+  } while (1);
+
+exit:
+  free(buf);
+  qcamlib_exit();
+  printf("DONE.\n");
+  return 0;
+}
-- 
1.9.1

