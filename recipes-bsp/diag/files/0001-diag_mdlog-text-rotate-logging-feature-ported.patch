From dbcc79a95cde9be26e4e37a0092c4f9999ef5f3d Mon Sep 17 00:00:00 2001
From: Suraj Swami <sswami@qti.qualcomm.com>
Date: Fri, 17 Apr 2015 16:49:15 -0700
Subject: [PATCH] diag_mdlog text,rotate logging feature ported

---
 include/diag_lsm.h |   38 ++++
 mdlog/diag_mdlog.c |   38 +++-
 src/diag_lsm.c     |  645 +++++++++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 714 insertions(+), 7 deletions(-)

diff --git a/include/diag_lsm.h b/include/diag_lsm.h
index fe990d4..7e00c41 100644
--- a/include/diag_lsm.h
+++ b/include/diag_lsm.h
@@ -309,6 +309,44 @@ SIDE EFFECTS
 boolean Diag_LSM_DeInit(void);
 
 
+/*===========================================================================
+FUNCTION enable_write_to_txt_file
+
+DESCRIPTION
+   When this flag is set, diag_mdlog also writes to txt in the same location as .qmdl file. 
+   
+DEPENDENCIES
+   
+===========================================================================*/
+void enable_write_to_txt_file(int txtFileFlag );
+
+
+/*===========================================================================
+FUNCTION enable_write_to_terminal
+
+DESCRIPTION
+   When this flag is set, diag_mdlog also writes to txt in the same location as .qmdl file.
+   
+   
+DEPENDENCIES
+   In the current code, we can write to terminal only if write to text file is enabled. 
+   
+===========================================================================*/
+void enable_write_to_terminal( int terminalFlag );
+
+
+/*===========================================================================
+FUNCTION enable_write_to_terminal
+
+DESCRIPTION
+   When this flag is set, diag_mdlog collect logs in rotation at /sdcard/diag_logs/rotate
+   
+   
+DEPENDENCIES
+   In the current code, we can write to terminal only if write to text file is enabled. 
+   
+===========================================================================*/
+void enable_log_rotation( int enablelFlag );
 #ifdef __cplusplus
 }
 #endif
diff --git a/mdlog/diag_mdlog.c b/mdlog/diag_mdlog.c
index 92196b0..8209f4d 100644
--- a/mdlog/diag_mdlog.c
+++ b/mdlog/diag_mdlog.c
@@ -77,6 +77,7 @@ when       who    what, where, why
 
 /* static data */
 static int dir_set = 0;
+static int rotate_set = 0;
 static int kill_mdlog = 0;
 static int dir_access = 0;
 static char mask_file_list[FILE_NAME_LEN] = "/sdcard/diag_logs/Diag_list.txt";
@@ -116,12 +117,15 @@ extern void flush_buffer(int);
 
 static void usage(char *progname)
 {
-	printf("\n Usage for %s:\n", progname);
+	printf("\n Usage for 1 %s:\n", progname);
 	printf("\n-f, --filemsm:\t mask file name for MSM\n");
 	printf("\n-m, --filemdm:\t mask file name for MDM\n");
 	printf("\n-l, --filelist:\t name of file containing list of mask files\n");
 	printf("\n-o, --output:\t output directory name\n");
 	printf("\n-s, --size:\t maximum file size in MB\n");
+	printf("\n-t, --text:\t print logging to text file\n");
+	printf("\n-x, --terminal:\t print logging to terminal\n");
+	printf("\n-r, --rotate:\t collect log  in rotation at \\sdcard\diag_logs\\rotate\\diag_logs.xxx \n");	
 	printf("\n-w, --wait:\t waiting for directory\n");
 	printf("\n-n, --number:\t maximum file number\n");
 	printf("\n-k, --kill:\t kill existing instance of diag_mdlog\n");
@@ -129,7 +133,7 @@ static void usage(char *progname)
 	printf("\n-d  --disablecon:\t Disable console messages\n");
 	printf("\n-e  --enablelock:\t Run using wake lock to keep APPS processor on\n");
 	printf("\n-b  --nonrealtime:\t Have peripherals buffer data and send data in non-real-time\n");
-	printf("\n-r  --renamefiles:\t Rename dir/file names to time when closed\n");
+	printf("\n-q  --renamefiles:\t Rename dir/file names to time when closed\n");
 	printf("\n-h, --help:\t usage help\n");
 	printf("\ne.g. diag_mdlog -f <mask_file name> -o <output dir>"
 		       " -s <size in bytes> -c\n");
@@ -147,6 +151,9 @@ static void parse_args(int argc, char **argv)
 		{ "filelist",	1,	NULL,	'l'},
 		{ "output",	1,	NULL,	'o'},
 		{ "size",	1,	NULL,	's'},
+		{ "text",	0,	NULL,	't'},
+		{ "terminal",	0,	NULL,   'x'},
+		{ "rotate",	0,	NULL,	'r'},
 		{ "wait",       1,      NULL,   'w'},
 		{ "number",     1,      NULL,   'n'},
 		{ "kill",	0,	NULL,	'k'},
@@ -154,11 +161,11 @@ static void parse_args(int argc, char **argv)
 		{ "disablecon",	0,	NULL,	'd'},
 		{ "enablelock",	0,	NULL,	'e'},
 		{ "nonrealtime",0,	NULL,	'b'},
-		{ "renamefiles",0,	NULL,	'r'},
+		{ "renamefiles",0,	NULL,	'q'},
 		{ "help",	0,	NULL,	'h'},
 	};
 
-	while ((command = getopt_long(argc, argv, "f:m:l:o:s:w:n:cdkebrh", longopts, NULL))
+	while ((command = getopt_long(argc, argv, "f:m:l:o:s:w:n:cdkebqxtrh", longopts, NULL))
 			!= -1) {
 		switch (command) {
 			case 'f':
@@ -187,6 +194,18 @@ static void parse_args(int argc, char **argv)
 					max_file_size *= 1024 * 1024;
 				min_file_size = ((max_file_size / 100) * 80);
 				break;
+			case 't':
+					enable_write_to_txt_file(TRUE);
+					DIAG_LOGE("diag_mdlog: Enable writing to text file\n");
+					break;
+			case 'x':
+					enable_write_to_terminal(TRUE);
+					DIAG_LOGE("diag_mdlog: Enable logging to terminal\n");
+					break;
+			case 'r':
+					enable_log_rotation(TRUE);
+					rotate_set = 1;	
+				break;
 			case 'w':
 				strlcpy(dir_name, optarg, FILE_NAME_LEN);
 				dir_access = 1;
@@ -214,7 +233,7 @@ static void parse_args(int argc, char **argv)
 			case 'b':
 				enable_nonrealtime = 1;
 				break;
-			case 'r':
+			case 'q':
 				rename_file_names = 1;
 				rename_dir_name = 1;
 				break;
@@ -399,6 +418,7 @@ int main(int argc, char *argv[])
 	struct itimerval value, ovalue, pvalue;
 	struct sigaction sact;
 	int pid_fd;
+	int err_mdkir;
 	uint16 remote_mask = 0;
 	struct stat dir_stat;
 	int stat_count = 0;
@@ -469,6 +489,13 @@ int main(int argc, char *argv[])
 	}
 
 	/* Setup the directory that we will be logging to */
+	if ( rotate_set == 1 ){
+	 
+    	DIAG_LOGE("Collecting logs at /sdcard/diag_logs/rotate/diag_logs.xxx \n");
+		strlcpy(output_dir[MSM], "/sdcard/diag_logs/rotate", FILE_NAME_LEN);
+    
+      }else{
+	/* Setup the directory that we will be logging to */
 	if (dir_set) {
 		if (rename_dir_name) {
 			/* Two somewhat conflicting command line parameters
@@ -525,6 +552,7 @@ int main(int argc, char *argv[])
 		}
 	}
 
+	}
 
 	/*
 	 * Since On Device Logging optimizations have implemented
diff --git a/src/diag_lsm.c b/src/diag_lsm.c
index 223dae4..1c2a670 100644
--- a/src/diag_lsm.c
+++ b/src/diag_lsm.c
@@ -112,15 +112,19 @@ and made common later. */
 	int fd = -1;		/* File descriptor for DIAG device */
 	/* File descriptor for Memory device */
 	int fd_md[NUM_PROC] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
+    int fd_md_txt[NUM_PROC] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};  /* File descriptor for Memory device */
 	int fd_uart = -1;	/* File descriptor for UART device */
 	int fd_socket[MAX_CHANNELS] = {-1, -1};	/* File descriptor for socket */
 	int fd_dev = -1;	/* Generic file descriptor */
+	int fd_dev_txt = -1;	/* Generic file descriptor */
 	int num_bytes_read;
 	unsigned long count_written_bytes[NUM_PROC];
 	/* This is for non MEMORY logging*/
 	unsigned long count_written_bytes_1 = 0;
 	char file_name_curr[NUM_PROC][FILE_NAME_LEN];
+    char file_name_curr_txt[NUM_PROC][FILE_NAME_LEN];
 	char file_name_del[FILE_NAME_LEN] = "/sdcard/diag_logs/diag_log_";
+    char file_name_del_txt[FILE_NAME_LEN] = "/sdcard/diag_logs/diag_log_";
 	char mask_file[FILE_NAME_LEN] = "/sdcard/diag_logs/Diag.cfg";
 	char mask_file_mdm[FILE_NAME_LEN] = "/sdcard/diag_logs/Diag.cfg";
 	char output_dir[NUM_PROC][FILE_NAME_LEN] = {
@@ -161,6 +165,7 @@ static char *wl_name;
 
 /* This event will be set (by DCM) when a mask change occurs. */
 //HANDLE ghMask_Sync_Event = NULL;
+//#define EXTRA_DEBUGGING_PRINTS
 
 #define NUM_SYNC_EVENTS_DIAG_LSM 2
 #define SYNC_EVENT_DIAG_LSM_PKT_IDX 0
@@ -1509,6 +1514,601 @@ int delete_log(int type)
 	return 0;
 }
 
+/* 65536 + 1024 ( extra buffer for the previous frame )*/
+#define MAX_MESSAGE_ARGUMENTS 8
+unsigned char DecodedFrame[66560];
+int decodedLen = 0;
+int false = 0;
+int true = 1;
+
+/* Stores the data to be written to the txt file.  */ 
+char WritetoFileBuffer[66560];
+
+/* Default printToTerminal set to FALSE. */
+int printToTerminalFlag = FALSE;
+int printToTxtFileFlag = FALSE;
+int enableLogRotationFlag = FALSE;
+
+/*===========================================================================
+FUNCTION   record_and_print_time
+
+DESCRIPTION
+  Used for prolifing the program. 
+  
+
+DEPENDENCIES
+  
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+void record_and_print_time(char str[] , int reset , int sub_reset )
+{
+	
+#ifdef ENABLE_PROFILING	
+	static clock_t clock_reading_start = 0, clock_reading_sub_start = 0 , clock_reading_current = 0 , clock_reading_previous = 0;
+    float cpu_time_from_start_secs , cpu_time_from_sub_start_secs , cpu_time_from_previous_secs;	
+	if (reset == 1)	
+	{
+		clock_reading_start = clock();
+		clock_reading_sub_start = clock();
+		clock_reading_previous = clock();
+		
+		DIAG_LOGE("===========================Initialize profiling =========================\n");
+		
+		if ( str != NULL)
+			DIAG_LOGE(str);
+
+		DIAG_LOGE("\t:\t Time from previous = %f , Time from start = %f \n", 0.0 , 0.0);
+		
+	}else{
+		
+		clock_reading_current = clock();
+		
+		if ( sub_reset )
+		{
+			clock_reading_sub_start = clock();
+		}
+		cpu_time_from_start_secs = ((float) (clock_reading_current - clock_reading_start)) / CLOCKS_PER_SEC;
+		cpu_time_from_sub_start_secs = ((float) (clock_reading_current - clock_reading_sub_start)) / CLOCKS_PER_SEC;
+		cpu_time_from_previous_secs = ((float) (clock_reading_current - clock_reading_previous)) / CLOCKS_PER_SEC;			
+		
+		if ( str != NULL)
+			DIAG_LOGE(str);
+				
+		//DIAG_LOGE("\t:\t Time from previous = %f , Time from start = %f  Time from sub start = %f \n", cpu_time_from_previous_secs , cpu_time_from_start_secs , cpu_time_from_sub_start_secs);
+		DIAG_LOGE("\t: %f , %f , %f \n", cpu_time_from_previous_secs , cpu_time_from_start_secs , cpu_time_from_sub_start_secs);
+		clock_reading_previous = clock_reading_current;
+			
+	}
+#endif /* ENABLE_PROFILING */
+	
+}
+
+/*===========================================================================
+FUNCTION DumpFrame
+
+DESCRIPTION
+   Print hex and value from the mentioned memory location and mentioned length.
+   Used only for debugging purposes and in the main call flow.
+   
+DEPENDENCIES
+   
+===========================================================================*/
+void DumpFrame( unsigned char* ptr, int len )
+{
+	int i;
+	int j;
+	printf( "frame msg len[%d]\n", len );
+	printf( "\n================\n");
+	for( i = 0; i < len; i+=16 )
+	{
+		for( j = 0; j < 16; ++j )
+		{
+			if( (i+j) < len )
+			{
+				printf( "%02x ", ptr[i+j] );
+				if( j == 7 )
+					printf( "- " );
+			}
+		}
+		printf( "  " );
+		for( j = 0; j < 16; ++j )
+		{
+			if( (i+j) < len )
+				printf( "%c", ptr[i+j] );
+		}
+		printf( "\n" );
+
+	}
+	printf( "\n================\n");
+	//assert(1);
+}
+
+
+/*===========================================================================
+FUNCTION DecodePayload
+
+DESCRIPTION
+   Extracts argument values from the packet header to input array location. 
+   
+DEPENDENCIES
+   
+===========================================================================*/
+void DecodePayload( unsigned char* payload, int payLoadValues[], int numArgs )
+{
+	int i = 0, j  = 0;
+    
+    /* QXDM sends arguments of size 4 byte with lsb first. 
+		 * First Argument  : 
+		 * ts  = payload[0] << 0;
+		*  ts |= payload[1] << 8;
+		*  ts |= payload[2] << 16;
+		*  ts |= payload[3] << 24;
+		* 
+		*  Second Argument : 
+		* 
+		* x  = payload[4] << 0;
+		* x |= payload[5] << 8;
+		* x |= payload[6] << 16;
+		* x |= payload[7] << 24;
+		* 
+	*/
+
+	for ( i = 0 ; i < numArgs ; i++ )
+	{
+		payLoadValues[i] = 0 ;
+					 
+		for ( j = 0 ; j < 4; j++ )
+		{
+			payLoadValues[i] |= payload[ i*4 + j ] << j * 8;
+		}
+		
+	}	
+}
+
+/*===========================================================================
+FUNCTION HDLCDecoder
+
+DESCRIPTION
+   Extract data from HDLC decoded raw data
+   
+DEPENDENCIES
+   
+===========================================================================*/
+int HDLCDecoder( unsigned char* ptr, int len )
+{
+	int i = 0;
+	
+	if( len > 65536 || ptr == NULL)
+	{
+		printf( "Error: Cannot decode hdlc frame....exiting\n");
+		return -1;
+	}
+#ifdef EXTRA_DEBUGGING_PRINTS
+    DIAG_LOGE(" HDLC decoder start decodedLen = %d ", decodedLen);
+#endif    
+	while( i < len )
+	{
+		if( ptr[i] != 0x7d )
+		{
+			DecodedFrame[decodedLen++] = ptr[i];
+		}
+		else
+		{
+			DecodedFrame[decodedLen++] = ptr[++i] ^ 0x20;
+		}
+		i++;
+	}
+#ifdef EXTRA_DEBUGGING_PRINTS	
+	DIAG_LOGE(" New decodedLen = %d \n", decodedLen );
+#endif	
+	return 0;
+}
+
+/*===========================================================================
+FUNCTION GenerateWrite2FileBuf
+
+DESCRIPTION
+   The function generates the string(buffer) to be written to file or print on terminal. 
+   
+DEPENDENCIES
+   
+===========================================================================*/
+void GenerateWrite2FileBuf(char *result_ptr, char *timestampString_ptr, char *fileName_ptr , int lineNumber , char *fmtString_ptr , int payLoadValues[] , int numArgs , char *header_ptr )
+{
+	char missed_packet_string[10];
+	char lineNumberString[20];
+	char message[8192];
+	int print_result_string = 0;
+	
+	
+	if (  result_ptr == NULL || fileName_ptr == NULL || fmtString_ptr ==NULL || header_ptr  == NULL )
+	{
+			DIAG_LOGE("ERROR : Invalid ptr passed - result = %p ,f ileName =  %p , fmtString =  %p , header = %p", result_ptr , fileName_ptr , fmtString_ptr , header_ptr ); 
+	}
+	
+	
+	
+	switch ( numArgs )
+	{
+		case 0:
+			sprintf( message, fmtString_ptr);
+			break;
+			
+		case 1:
+			sprintf( message, fmtString_ptr, payLoadValues[0] );
+			break;
+		
+		case 2:
+			sprintf( message, fmtString_ptr, payLoadValues[0] , payLoadValues[1]);
+			break;
+			
+		case 3:
+			sprintf( message, fmtString_ptr, payLoadValues[0] , payLoadValues[1] , payLoadValues[2] );
+			break;
+			
+		case 4:
+			sprintf( message, fmtString_ptr, payLoadValues[0] , payLoadValues[1] , payLoadValues[2] , payLoadValues[3] );
+			break;
+		
+		case 5:
+			sprintf( message, fmtString_ptr, payLoadValues[0] , payLoadValues[1] , payLoadValues[2] , payLoadValues[3] , payLoadValues[4] );
+			break;
+			
+		case 6:
+			sprintf( message, fmtString_ptr, payLoadValues[0] , payLoadValues[1] , payLoadValues[2] , payLoadValues[3] , payLoadValues[4] , payLoadValues[5]);
+			break;
+			
+		default:
+			DIAG_LOGE("Only six parameter extended message is currently supported : %d \n",numArgs);
+			print_result_string = 1;
+			break;
+	
+    }
+    
+    strcpy( result_ptr , "");   /* Initialize empty string */ 
+    
+    strcat( result_ptr , timestampString_ptr );
+    strcat(result_ptr , "\t");
+	strcat( result_ptr , fileName_ptr ); /* Write file name to buffer */
+	
+	
+    sprintf( lineNumberString , "	%d	" , lineNumber ); /* Convert line number to string and write to buffer */
+    strcat( result_ptr , lineNumberString );
+     
+    strcat(result_ptr , message );               /* Write the message */
+	strcat(result_ptr ,"	0x79 00 04 ");
+	
+	sprintf( missed_packet_string , "%02d" ,  header_ptr[3]  );   /* Extra logging of raw header. Mainly to log number of missed packets. Hence only 4 bytes */
+    strcat(result_ptr , missed_packet_string ); 
+	strcat(result_ptr , " "); 
+	strcat( result_ptr,"\n");
+	
+	if ( print_result_string)
+	{
+		printf(" Result = %s \n", result_ptr );
+		print_result_string = 0;
+	}
+    return;
+}
+
+/*===========================================================================
+FUNCTION PrintToTxtFile
+DESCRIPTION
+   Prints the input buffer to a file using linux system call write.
+   
+DEPENDENCIES
+   
+===========================================================================*/
+int PrintToTxtFile( const char *packetBuf )
+{
+	long int i;
+	size_t nbytes =0,bytes_written_to_file = 0;
+	int return_value = 0;
+    static long int bytes_written_to_buffer = 0;
+   	
+	if ( packetBuf  == NULL )
+	{
+		DIAG_LOGE("Error : Cannot write empty buffer to file");
+		return -1;
+	}	
+	nbytes = strlen(packetBuf);
+	
+    /* Store the data in a buffer instead of writing to file each time */
+	for( i = 0 ; i < nbytes ; i++)
+	{
+		WritetoFileBuffer[bytes_written_to_buffer++] = packetBuf[i];
+		
+	}
+	
+    /* Write to file only if available data exceeds 65536 */
+	if (bytes_written_to_buffer >= 65536 )
+	{
+		/* fd_md_txt is a global file descriptor which is set in the function  log_to_device */
+		bytes_written_to_file = write(fd_dev_txt, WritetoFileBuffer, bytes_written_to_buffer);
+	    if( bytes_written_to_buffer !=  bytes_written_to_file )
+	    {
+			DIAG_LOGE(" Error : %d number of bytes not written to file: ", nbytes - bytes_written_to_file);
+			return_value = -1;
+	    }
+	    #ifdef EXTRA_DEBUGGING_PRINTS	       
+			DIAG_LOGE("DEBUG : %d Written to file \n", bytes_written_to_buffer);		
+		#endif /* EXTRA_DEBUGGING_PRINTS */	
+	    bytes_written_to_buffer = 0;
+	    
+    }
+        
+    if ( printToTerminalFlag == TRUE )
+    {
+		DIAG_LOGE(packetBuf);
+	}
+
+	return return_value ;	
+}
+
+int round(float x)
+{
+    return (int)(x + 0.5);
+}
+
+/*===========================================================================
+FUNCTION WriteToTextFile
+
+DESCRIPTION
+   Parses diag data and writes to a file.  
+   
+DEPENDENCIES
+   
+===========================================================================*/
+int WriteToTextFile( unsigned char* ptr, int len )
+{
+	int i = 0;
+	int indexDF =0 ;  /* index to traverse through decodedFrame and search for 0x79 ( exteneded message) */  
+	int indexExtraByte =0;	 /* index to save extra/incomplete bytes of last frames*/
+	
+	
+	unsigned char* header;  /* starting address of valid packet */
+	int numArgs;
+	
+	char timestampString[120]= "";   /* buffer to save the string in 1980-01-06 00:58:56.478 format */
+	long long int msCounter;         
+    int chipCounter , chipCounterMicroSeconds;
+    long long int seconds, microSeconds;
+
+    struct tm  timestamp_tm;    
+    char temp_char_buf[20];
+    
+	
+	unsigned int lineNumber;
+	
+	unsigned char* payload;  /* starting address of Args */
+	unsigned char* fmtString;  /* starting address of formated string */
+	unsigned char* fileName; 
+    unsigned char* frameCRC;        	
+	
+	
+	int pktLen;    		
+	char write2FileBuf[1000] = "";   
+    int payLoadValues[MAX_MESSAGE_ARGUMENTS];
+     
+    
+    record_and_print_time("HDLC Decoder Start",0,1);
+    HDLCDecoder( ptr, len );
+    record_and_print_time("HDLC Decoder End",0,0);
+          
+	if( decodedLen == -1 )
+		return -1;
+
+    record_and_print_time("Log Parsing Start",0 ,0);
+	/* traverse through hdlc decoded buffer to find 0x79 which extended debug message of QXDM
+	 * After which extract information from the buffer
+	*/
+	indexDF = 0; 
+	while( indexDF < decodedLen )
+	{
+		if( DecodedFrame[indexDF] != 0x79 ) 
+		{
+			indexDF++;
+			continue;
+		}
+	
+		if( indexDF + 20 > decodedLen ) // not enough header
+		{
+		    #ifdef EXTRA_DEBUGGING_PRINTS
+				DIAG_LOGE("Not enough header : Saving bytes for next frame : Extra = %d , indexDF = %d , decodedLen =%d , len = %d , pktLen = %d \n", ( decodedLen - indexDF ) , indexDF, decodedLen, len, pktLen );
+			#endif 	
+			indexExtraByte = 0 ; /* j traverse from start of DecodedFrame to save pending bytes */
+			while( indexDF < decodedLen )
+			{
+				DecodedFrame[indexExtraByte++] = DecodedFrame[indexDF++]; 
+			}
+			decodedLen = indexExtraByte; 
+			break;
+	    }
+	
+		record_and_print_time("Log Packet BEG",0,1);	
+		/*Extract message */
+		header = &DecodedFrame[indexDF];
+		
+			
+		numArgs = header[2]; // the 3rd byte is the count of args.			
+		payload = header + 20;
+		fmtString = payload + numArgs*4;
+		fileName = fmtString + strlen( (char*)fmtString ) + 1;
+		
+		lineNumber  = 0;
+		lineNumber  =  header[12]; /* Line number is 2 byte and is stored at 13 and 14th bytes */
+		lineNumber |= header[13] << 8 ;
+		
+		
+		/*
+		  chip counter                     ms counter
+		   LSB	  USB		LSB                                   USB
+		 
+		  --0--  --0--     --b1--  --e3--  --3a--  --0--  --0--  --0--		
+		  header[4]       header[6]                             header[11]  
+		*/
+		msCounter = 0;		
+		chipCounter = 0;
+		chipCounter = header[4] ;               /* I got all chipCounter value = 0 in my testing. But still using it to actual time calculation */
+		chipCounter |= header[5] << 8 ;
+		
+		/* The 1/32 chip counter has 1.25 ms dynamic range. It rolls over at count 49152. Each tick  1.25 / 49152 =  0.000025431 ms */
+		chipCounterMicroSeconds = 	round(chipCounter * 0.000025431);
+			
+		for (   i =0 ;  i < 6 ; i++){
+			
+			    msCounter |= header[6 +i] << 8 * i;					
+		}
+		
+		/* mscounter ticks every 1.25 ms */
+		microSeconds = round( msCounter * 1.25);		
+		microSeconds = microSeconds + chipCounterMicroSeconds; /*Total microseconds */		
+		
+		seconds = microSeconds / 1000 ;  /* total seconds since Jan 6, 1980 */
+		microSeconds = microSeconds % 1000;  
+		
+			
+	    
+		seconds = seconds + 315964800  ;     /* (10*365+5+2)*24*60*60 : total seconds since epoch after adding offset of Jan 6, 1980 */
+
+		timestamp_tm = *localtime(&seconds);   /* Convert from seconds to 1980-01-06 00:58:56.478 format */ 
+		strcpy(timestampString,"");		
+		strftime(timestampString, sizeof(timestampString), " %Y-%m-%d %H:%M:%S", &timestamp_tm);
+		sprintf(temp_char_buf,".%03d",microSeconds);
+        strcat( timestampString,temp_char_buf);
+        //printf("time = %s\n", timestampString);
+
+	
+		frameCRC = fileName + strlen( (char*)fileName ) + 1;
+		pktLen = 20 + numArgs*4 + strlen( (char*)fmtString ) + 1 + strlen((char*) fileName ) + 1 + 3;
+		
+	    
+	    if( header[3] != 0 ) // the 4rd byte is the count of missed packets
+		{			
+			DIAG_LOGE("%s : Warning! [%d] qxdm packets dropped\n", timestampString, header[3] );
+			sprintf(write2FileBuf, "%s : Warning! [%d] qxdm packets dropped \n", timestampString , header[3] );			
+			//DumpFrame(&header[0], 200);
+			PrintToTxtFile( write2FileBuf );			
+		}    
+		
+ #ifdef EXTRA_DEBUGGING_PRINTS     
+        if ( numArgs > 6 )
+        {
+			DIAG_LOGE(" num Args = %d :indexDF = %d , decodedLen =%d , len = %d , pktLen = %d  indexExtraByte = %d\n",numArgs ,indexDF, decodedLen, len, pktLen , indexExtraByte );
+		}
+ #endif
+    
+		if (fmtString != NULL )		
+		{								
+			/* Check if the complete packet is in the current frame else save bytes to be concatenate with the start of next frame */	
+			if ( pktLen > ( decodedLen - indexDF ) )
+			{	
+				//DumpFrame( DecodedFrame[indexDF] , 15 );
+				#ifdef EXTRA_DEBUGGING_PRINTS
+					DIAG_LOGE(" Incomplete packet: Saving bytes for next frame : Extra = %d , indexDF = %d , decodedLen =%d , len = %d , pktLen = %d \n", ( decodedLen - indexDF ) , indexDF, decodedLen, len, pktLen );
+				#endif 	
+				indexExtraByte = 0 ; /* j traverse from start of DecodedFrame to save pending bytes */
+				while( indexDF < decodedLen )
+				{
+					DecodedFrame[indexExtraByte++] = DecodedFrame[indexDF++]; 
+				}
+				decodedLen = indexExtraByte; 
+				break;										
+				
+				
+			}
+			else 
+			{	
+				record_and_print_time("D-P-load S",0,0);
+				DecodePayload( payload, payLoadValues , numArgs );
+				record_and_print_time("D-P-load E",0,0);
+				
+				record_and_print_time("G W2Buf S",0,0);
+				GenerateWrite2FileBuf( write2FileBuf , timestampString , fileName , lineNumber , fmtString , payLoadValues , numArgs , header ); 
+				record_and_print_time("G W2Buf E",0,0);
+				
+				record_and_print_time("P2file S",0,0);
+				PrintToTxtFile( write2FileBuf );
+				record_and_print_time("P2file E",0,0); 				              				
+			}
+			//DIAG_LOGE( "DecodedFrame: pktLen[%d] args[%d] fmtStr[%s] fileName[%s]\n", pktLen, numArgs, fmtString, fileName );
+		}
+
+
+		indexDF += pktLen;
+		
+		record_and_print_time("Log Packet End",0,0);
+	}
+	record_and_print_time("Log Parsing End",0,0);
+	
+#ifdef EXTRA_DEBUGGING_PRINTS	
+	DIAG_LOGE(" Debug End of buffer :indexDF = %d , decodedLen =%d , len = %d , pktLen = %d  indexExtraByte = %d\n",indexDF, decodedLen, len, pktLen , indexExtraByte );
+#endif		
+
+	/* No bytes will be reused in the next frame if indexExtraByte = 0 */
+	if ( indexExtraByte == 0 )
+	{
+	   decodedLen = 0 ;		 	
+	}
+
+	return 0;
+}
+
+/*===========================================================================
+FUNCTION enable_write_to_txt_file
+
+DESCRIPTION
+   When this flag is set, diag_mdlog also writes to txt in the same location as .qmdl file. 
+   
+DEPENDENCIES
+   
+===========================================================================*/
+void enable_write_to_txt_file(int txtFileFlag )
+{
+	printToTxtFileFlag = txtFileFlag;			
+}
+
+/*===========================================================================
+FUNCTION enable_write_to_terminal
+
+DESCRIPTION
+   When this flag is set, diag_mdlog also writes to txt in the same location as .qmdl file.
+   
+   
+DEPENDENCIES
+   In the current code, we can write to terminal only if write to text file is enabled. 
+   
+===========================================================================*/
+void enable_write_to_terminal( int terminalFlag )
+{
+	 
+		printToTerminalFlag = terminalFlag;
+	
+}
+
+/*===========================================================================
+FUNCTION enable_write_to_terminal
+
+DESCRIPTION
+   When this flag is set, diag_mdlog collect logs in rotation at /sdcard/diag_logs/rotate
+   
+   
+DEPENDENCIES
+   In the current code, we can write to terminal only if write to text file is enabled. 
+   
+===========================================================================*/
+void enable_log_rotation( int enablelFlag )
+{
+	 
+	enableLogRotationFlag = enablelFlag;
+	
+}
 /*
  * NOTE: Please always pass type as -1, type is only valid for mdlog.
  *
@@ -1602,11 +2202,17 @@ void log_to_device(unsigned char *ptr, int logging_mode, int size, int type)
 				strftime(timestamp_buf,30,"%Y%m%d_%H%M%S",tm_ptr);
 			else
 				strlcpy(timestamp_buf, "00000000_000000", 30);
+			if ( enableLogRotationFlag == TRUE)
+			{
+				(void)std_strlprintf(file_name_curr[type], FILE_NAME_LEN, "%s%s%s",output_dir, "/diag_log",".qmdl");					
+			
+			}else{	
 			(void)std_strlprintf(file_name_curr[type],
 					FILE_NAME_LEN, "%s%s%s%s",
 					output_dir[type],"/diag_log_",
 					timestamp_buf, ".qmdl");
 
+            }
 			fd_md[type] = open(file_name_curr[type],
 					O_CREAT | O_RDWR | O_SYNC | O_TRUNC,
 					0644);
@@ -1617,10 +2223,38 @@ void log_to_device(unsigned char *ptr, int logging_mode, int size, int type)
 							fd_md[type], errno);
 			}
 			else {
-				DIAG_LOGE(" creating new file %s \n",
+				DIAG_LOGE(" creating new qmdl file %s \n",
 							file_name_curr[type]);
 				file_count++;
 			}
+			if ( printToTxtFileFlag  == TRUE )					
+			{	
+				if ( enableLogRotationFlag == TRUE)
+				{
+					(void)std_strlprintf(file_name_curr_txt[type], FILE_NAME_LEN, "%s%s%s",output_dir, "/diag_log",".txt");					
+				
+				}else
+				{
+					(void)std_strlprintf(file_name_curr_txt[type],
+							FILE_NAME_LEN, "%s%s%s%s",
+							output_dir[type],"/diag_log_",
+							timestamp_buf, ".txt");	
+				}
+				
+				fd_md_txt[type] = open(file_name_curr_txt[type],
+							O_CREAT | O_RDWR | O_SYNC | O_TRUNC,
+							0644);
+				fd_dev_txt = fd_md_txt[type];
+				if (fd_md_txt[type] < 0) {
+					DIAG_LOGE(" File open error, please check");
+					DIAG_LOGE(" memory device %d, errno: %d \n",
+								fd_md[type], errno);
+				}
+				else {
+					DIAG_LOGE(" creating new txt  file %s \n",
+								file_name_curr_txt[type]);
+				}
+			}
 		} else if ((logging_mode == UART_MODE) ||
 					(logging_mode == SOCKET_MODE))
 				DIAG_LOGE(" Invalid file descriptor\n");
@@ -1628,6 +2262,13 @@ void log_to_device(unsigned char *ptr, int logging_mode, int size, int type)
 	if (fd_dev != -1) {
 		if(logging_mode == MEMORY_DEVICE_MODE ){
 			ret = write(fd_dev, (const void*) base_ptr, size);
+            if ( printToTxtFileFlag == TRUE )					
+			{	
+				record_and_print_time("Begin WriteToTextFile",1 ,0);
+				WriteToTextFile(base_ptr,size);
+				record_and_print_time("End WriteToTextFile",0 , 0);
+				
+			}
 			if ( ret > 0) {
 				count_written_bytes[type] += size;
 			}else {
@@ -1805,7 +2446,7 @@ void log_to_device(unsigned char *ptr, int logging_mode, int size, int type)
 		} else
 			DIAG_LOGE("diag: Incorrect logging mode\n");
 		if ((logging_mode == MEMORY_DEVICE_MODE) &&
-			(count_written_bytes[type] >= max_file_size)) {
+			(count_written_bytes[type] >= max_file_size) && (enableLogRotationFlag != TRUE)) {
 			close_logging_file(type, ODL_IN_PROGRESS);
 			fd_dev = fd_md[type];
 			count_written_bytes[type] = 0;
-- 
1.7.9.5

