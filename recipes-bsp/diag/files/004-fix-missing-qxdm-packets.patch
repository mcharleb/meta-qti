diff --git a/mdlog/diag_mdlog.c b/mdlog/diag_mdlog.c
index d97ae1f..befcc96 100755
--- a/mdlog/diag_mdlog.c
+++ b/mdlog/diag_mdlog.c
@@ -120,7 +120,7 @@ static void parse_args(int argc, char **argv)
 		{ "help",	0,	NULL,	'h'},
 	};
 
-	while ((command = getopt_long(argc, argv, "f:o:s:ckh:x:t", longopts, NULL))
+	while ((command = getopt_long(argc, argv, "f:o:s:ckhxt", longopts, NULL))
 			!= -1) {
 		switch (command) {
 			case 'f':
@@ -301,8 +301,10 @@ int main(int argc, char *argv[])
 	DIAG_LOGE("\ndiag_mdlog: Diag_LSM_Init succeeded.\n");
 
 	/* Make sure the default directory exists so the diag_pid file can be placed there */
-	mkdir("/sdcard/diag_logs", 0770);
+	//mkdir("/sdcard/diag_logs", 0770);
 
+    DIAG_LOGE("Debug : dir_set = %d Output dir = %s ", dir_set, output_dir);
+    
 	/* Setup the directory that we will be logging to */
 	if (dir_set && (mkdir(output_dir, 0770) == 0)) {
 		DIAG_LOGE("diag_mdlog: Created logging directory %s\n", output_dir);
diff --git a/src/diag_lsm.c b/src/diag_lsm.c
index 9cdce84..a3e3a13 100755
--- a/src/diag_lsm.c
+++ b/src/diag_lsm.c
@@ -21,7 +21,7 @@ INITIALIZATION AND SEQUENCING REQUIREMENTS
 
 /*===========================================================================
 
-                        EDIT HISTORY FOR MODULE
+                    EDIT HISTORY FOR MODULE
 
 $Header: 
 
@@ -120,11 +120,15 @@ and made common later. */
 /* This event will be set (by DCM) when a mask change occurs. */
 //HANDLE ghMask_Sync_Event = NULL;
 
+//#define EXTRA_DEBUGGING_PRINTS
+
 #define NUM_SYNC_EVENTS_DIAG_LSM 2
 #define SYNC_EVENT_DIAG_LSM_PKT_IDX 0
 #define SYNC_EVENT_DIAG_LSM_MASK_IDX 1
 #define READ_BUF_SIZE 100000
 #define DISK_BUF_SIZE 1024*128*2
+#define INCREASE_NUM_BUFFER
+#define NUMBER_OF_BUFFERS 20
 #define DISK_FLUSH_THRESHOLD  1024*128
 
 #define FILE_LIST_NAME_SIZE 30
@@ -213,7 +217,12 @@ SIDE EFFECTS
 volatile int curr_write;
 volatile int curr_read;
 volatile int  write_in_progress;
-unsigned char buffer[2][DISK_BUF_SIZE];
+#ifdef INCREASE_NUM_BUFFER 
+	unsigned char buffer[NUMBER_OF_BUFFERS][DISK_BUF_SIZE];
+#else
+	unsigned char buffer[2][DISK_BUF_SIZE];
+#endif	
+
 pthread_mutex_t stop_mutex;
 pthread_cond_t stop_cond;
 
@@ -238,19 +247,48 @@ struct buffer_pool {
 
 };
 
-struct buffer_pool pools[] = {
-	[0] = {
-		.free		=	1,
-		.data_ready	=	0,
-		.buffer_ptr	=	buffer[0],
-	},
-	[1] = {
-		.free		=	1,
-		.data_ready	=	0,
-		.buffer_ptr	=	buffer[1],
-	},
+#ifdef INCREASE_NUM_BUFFER
+	struct buffer_pool pools[NUMBER_OF_BUFFERS];
+
+/*=========================================================================
+ * FUNCTION initialize_buffer_pool
+ * DESCRIPTION
+ *    Initializes buffer pool to store data read from /dev/diag     
+ * RETURN VALUE
+ *    NONE
+ * SIDE EFFECTS
+ *    NONE
+ *========================================================================*/
+
+	void initialize_buffer_pool()
+	{
+		int i = 0;
+		for ( i = 0 ; i < NUMBER_OF_BUFFERS ; i++ )
+		{
+			pools[i].free		=	1;
+			pools[i].data_ready	=	0;
+			pools[i].buffer_ptr	=	buffer[i];
+		}
+	}
+#else
+
+	struct buffer_pool pools[2] = {
+		[0] = {
+			.free		=	1,
+			.data_ready	=	0,
+			.buffer_ptr	=	buffer[0],
+		},
+		[1] = {
+			.free		=	1,
+			.data_ready	=	0,
+			.buffer_ptr	=	buffer[1],
+		},
+
+	};
+#endif
+
+
 
-};
 
 /*===============================================*/
 
@@ -302,6 +340,10 @@ SIDE EFFECTS
 ===========================================================================*/
 void flush_buffer(int signal)
 {
+
+#ifdef INCREASE_NUM_BUFFER
+	int i;
+#endif
 	DIAG_LOGE("diag: Signal received\n");
 
 	flush_log = 1;
@@ -311,18 +353,37 @@ void flush_buffer(int signal)
 		pthread_kill(read_thread_hdl, SIGSTOP);
 		pthread_kill(read_thread_hdl, SIGCONT);
 	}
-
+/* flush_log is incremented in the fuction : CreateWaitThread */
+#ifdef INCREASE_NUM_BUFFER
+	while(flush_log != (NUMBER_OF_BUFFERS + 1)) {
+		sleep(1);
+	}
+#else
 	while(flush_log != 3) {
 		sleep(1);
 	}
+#endif
+
 	pthread_mutex_lock(&stop_mutex);
 	flush_log = 0;
 	/* Clean up */
 	write_in_progress = 0;
 	in_read = 0;
+	
 	curr_write = curr_read = 0;
+	
+#ifdef INCREASE_NUM_BUFFER
+	for ( i = 0 ; i < NUMBER_OF_BUFFERS ; i++ )
+	{
+	  pools[i].free = 1;
+	  pools[i].data_ready = 0;	
+	}
+#else
 	pools[0].free =  pools[1].free = 1;
 	pools[0].data_ready = pools[1].data_ready = 0;
+#endif	
+
+	
 
 	DIAG_LOGE("diag: Sending cond to CreateWaitThread\n");
 	pthread_cond_signal(&stop_cond);
@@ -335,14 +396,27 @@ void flush_buffer(int signal)
 			DIAG_LOGE("diag: Sending empty mask \n");
 			send_empty_mask();
 		}
-		pthread_mutex_destroy(&(pools[0].write_mutex));
-		pthread_cond_destroy(&(pools[0].write_cond));
-		pthread_mutex_destroy(&(pools[0].read_mutex));
-		pthread_cond_destroy(&(pools[0].read_cond));
-		pthread_mutex_destroy(&(pools[1].write_mutex));
-		pthread_cond_destroy(&(pools[1].write_cond));
-		pthread_mutex_destroy(&(pools[1].read_mutex));
-		pthread_cond_destroy(&(pools[1].read_cond));
+		
+#ifdef INCREASE_NUM_BUFFER
+	for ( i = 0 ; i < NUMBER_OF_BUFFERS ; i++)		
+	{
+		pthread_mutex_destroy(&(pools[i].write_mutex));
+		pthread_cond_destroy(&(pools[i].write_cond));
+		pthread_mutex_destroy(&(pools[i].read_mutex));
+		pthread_cond_destroy(&(pools[i].read_cond));
+    }
+		
+#else
+	pthread_mutex_destroy(&(pools[0].write_mutex));
+	pthread_cond_destroy(&(pools[0].write_cond));
+	pthread_mutex_destroy(&(pools[0].read_mutex));
+	pthread_cond_destroy(&(pools[0].read_cond));
+	pthread_mutex_destroy(&(pools[1].write_mutex));
+	pthread_cond_destroy(&(pools[1].write_cond));
+	pthread_mutex_destroy(&(pools[1].read_mutex));
+	pthread_cond_destroy(&(pools[1].read_cond));
+
+#endif		
 		DIAG_LOGE("diag: Exiting program \n");
 		exit(0);
 	}
@@ -448,7 +522,22 @@ static void process_diag_payload(void)
 							buffer[curr_read];
 				pthread_cond_signal(&pools[curr_read].write_cond);
 				pthread_mutex_unlock(&pools[curr_read].write_mutex);
-				curr_read = !curr_read;
+				
+				#ifdef INCREASE_NUM_BUFFER
+					/* Implement a circular queue instead of ping pong buffer*/
+					curr_read++;
+					if( curr_read >= NUMBER_OF_BUFFERS)
+					{
+						curr_read = 0;							
+					}
+					
+				#else
+					curr_read = !curr_read;
+				#endif
+				
+				#ifdef EXTRA_DEBUGGING_PRINTS
+					//DIAG_LOGE("DEBUG : Increment R curr_write = %d , curr_read = %d \n", curr_write , curr_read );		
+				#endif  /* EXTRA_DEBUGGING_PRINTS */	
 				return;
 			}
 			pthread_mutex_unlock(&pools[curr_read].write_mutex);
@@ -506,7 +595,23 @@ void *WriteToDisk (void *ptr)
 		pthread_mutex_unlock(&(pools[curr_write].read_mutex));
 		pthread_mutex_unlock(&(pools[curr_write].write_mutex));
 
-		curr_write = !curr_write;
+		#ifdef INCREASE_NUM_BUFFER
+		    /* Implement a circular queue instead of ping pong buffer */
+			curr_write++;
+			if( curr_write >= NUMBER_OF_BUFFERS )
+			{
+				curr_write = 0;
+				
+			}
+			
+			
+		#else
+			curr_write = !curr_write;
+		#endif
+		
+		#ifdef EXTRA_DEBUGGING_PRINTS
+			//DIAG_LOGE("DEBUG : Increment W curr_write = %d , curr_read = %d \n", curr_write , curr_read );		
+		#endif  /*  EXTRA_DEBUGGING_PRINTS	*/
 	}
 	return NULL;
 }
@@ -591,12 +696,74 @@ int decodedLen = 0;
 int false = 0;
 int true = 1;
 
-/* Default printToTerminal set to FALSE. 
-* ToDO: Set this value based on command line parameter */
+/* Stores the data to be written to the txt file.  */ 
+char WritetoFileBuffer[66560];
+
+/* Default printToTerminal set to FALSE. */
 int printToTerminalFlag = FALSE;
 int printToTxtFileFlag = FALSE;
 
 /*===========================================================================
+FUNCTION   record_and_print_time
+
+DESCRIPTION
+  Used for prolifing the program. 
+  
+
+DEPENDENCIES
+  
+
+RETURN VALUE
+  None
+
+SIDE EFFECTS
+  None
+
+===========================================================================*/
+void record_and_print_time(char str[] , int reset , int sub_reset )
+{
+	
+#ifdef ENABLE_PROFILING	
+	static clock_t clock_reading_start = 0, clock_reading_sub_start = 0 , clock_reading_current = 0 , clock_reading_previous = 0;
+    float cpu_time_from_start_secs , cpu_time_from_sub_start_secs , cpu_time_from_previous_secs;	
+	if (reset == 1)	
+	{
+		clock_reading_start = clock();
+		clock_reading_sub_start = clock();
+		clock_reading_previous = clock();
+		
+		DIAG_LOGE("===========================Initialize profiling =========================\n");
+		
+		if ( str != NULL)
+			DIAG_LOGE(str);
+
+		DIAG_LOGE("\t:\t Time from previous = %f , Time from start = %f \n", 0.0 , 0.0);
+		
+	}else{
+		
+		clock_reading_current = clock();
+		
+		if ( sub_reset )
+		{
+			clock_reading_sub_start = clock();
+		}
+		cpu_time_from_start_secs = ((float) (clock_reading_current - clock_reading_start)) / CLOCKS_PER_SEC;
+		cpu_time_from_sub_start_secs = ((float) (clock_reading_current - clock_reading_sub_start)) / CLOCKS_PER_SEC;
+		cpu_time_from_previous_secs = ((float) (clock_reading_current - clock_reading_previous)) / CLOCKS_PER_SEC;			
+		
+		if ( str != NULL)
+			DIAG_LOGE(str);
+				
+		//DIAG_LOGE("\t:\t Time from previous = %f , Time from start = %f  Time from sub start = %f \n", cpu_time_from_previous_secs , cpu_time_from_start_secs , cpu_time_from_sub_start_secs);
+		DIAG_LOGE("\t: %f , %f , %f \n", cpu_time_from_previous_secs , cpu_time_from_start_secs , cpu_time_from_sub_start_secs);
+		clock_reading_previous = clock_reading_current;
+			
+	}
+#endif /* ENABLE_PROFILING */
+	
+}
+
+/*===========================================================================
 FUNCTION DumpFrame
 
 DESCRIPTION
@@ -649,7 +816,6 @@ DEPENDENCIES
 void DecodePayload( unsigned char* payload, int payLoadValues[], int numArgs )
 {
 	int i = 0, j  = 0;
-	static int count_local = 0;
     
     /* QXDM sends arguments of size 4 byte with lsb first. 
 		 * First Argument  : 
@@ -688,16 +854,18 @@ DESCRIPTION
 DEPENDENCIES
    
 ===========================================================================*/
-void HDLCDecoder( unsigned char* ptr, int len )
+int HDLCDecoder( unsigned char* ptr, int len )
 {
 	int i = 0;
 	
-	if( len > 65536 )
+	if( len > 65536 || ptr == NULL)
 	{
 		printf( "Error: Cannot decode hdlc frame....exiting\n");
 		return -1;
 	}
-
+#ifdef EXTRA_DEBUGGING_PRINTS
+    DIAG_LOGE(" HDLC decoder start decodedLen = %d ", decodedLen);
+#endif    
 	while( i < len )
 	{
 		if( ptr[i] != 0x7d )
@@ -710,6 +878,10 @@ void HDLCDecoder( unsigned char* ptr, int len )
 		}
 		i++;
 	}
+#ifdef EXTRA_DEBUGGING_PRINTS	
+	DIAG_LOGE(" New decodedLen = %d \n", decodedLen );
+#endif	
+	return 0;
 }
 
 /*===========================================================================
@@ -721,16 +893,17 @@ DESCRIPTION
 DEPENDENCIES
    
 ===========================================================================*/
-void GenerateWrite2FileBuf(unsigned char *result_ptr, unsigned char *timestampString_ptr, unsigned char *fileName_ptr , int lineNumber , unsigned char *fmtString_ptr , int payLoadValues[] , int numArgs , unsigned char *header_ptr )
+void GenerateWrite2FileBuf(char *result_ptr, char *timestampString_ptr, char *fileName_ptr , int lineNumber , char *fmtString_ptr , int payLoadValues[] , int numArgs , char *header_ptr )
 {
 	char missed_packet_string[10];
 	char lineNumberString[20];
 	char message[8192];
+	int print_result_string = 0;
 	
 	
 	if (  result_ptr == NULL || fileName_ptr == NULL || fmtString_ptr ==NULL || header_ptr  == NULL )
 	{
-			DIAG_LOGE("ERROR : Invalid ptr passed - result = %u ,f ileName =  % u , fmtString =  %u , header = %u", result_ptr , fileName_ptr , fmtString_ptr , header_ptr ); 
+			DIAG_LOGE("ERROR : Invalid ptr passed - result = %p ,f ileName =  %p , fmtString =  %p , header = %p", result_ptr , fileName_ptr , fmtString_ptr , header_ptr ); 
 	}
 	
 	
@@ -763,7 +936,12 @@ void GenerateWrite2FileBuf(unsigned char *result_ptr, unsigned char *timestampSt
 			
 		case 6:
 			sprintf( message, fmtString_ptr, payLoadValues[0] , payLoadValues[1] , payLoadValues[2] , payLoadValues[3] , payLoadValues[4] , payLoadValues[5]);
-			break;						
+			break;
+			
+		default:
+			DIAG_LOGE("Only six parameter extended message is currently supported : %d \n",numArgs);
+			print_result_string = 1;
+			break;
 	
     }
     
@@ -785,7 +963,11 @@ void GenerateWrite2FileBuf(unsigned char *result_ptr, unsigned char *timestampSt
 	strcat(result_ptr , " "); 
 	strcat( result_ptr,"\n");
 	
-	//printf(" To write  = %s \n", result_ptr );
+	if ( print_result_string)
+	{
+		printf(" Result = %s \n", result_ptr );
+		print_result_string = 0;
+	}
     return;
 }
 
@@ -797,29 +979,47 @@ DESCRIPTION
 DEPENDENCIES
    
 ===========================================================================*/
-int PrintToTxtFile( const char *write2FileBuf )
+int PrintToTxtFile( const char *packetBuf )
 {
-	size_t nbytes =0,bytes_written = 0;
+	long int i;
+	size_t nbytes =0,bytes_written_to_file = 0;
 	int return_value = 0;
-	
-	if ( write2FileBuf == NULL )
+    static long int bytes_written_to_buffer = 0;
+   	
+	if ( packetBuf  == NULL )
 	{
 		DIAG_LOGE("Error : Cannot write empty buffer to file");
 		return -1;
 	}	
-	nbytes = strlen(write2FileBuf);
+	nbytes = strlen(packetBuf);
 	
-	/* fd_md_txt is a global file descriptor which is set in the function  log_to_device */
-    bytes_written = write(fd_md_txt, write2FileBuf, nbytes);
-    if( nbytes !=  bytes_written )
-    {
-		DIAG_LOGE(" Error : %d number of bytes not written to file: ", nbytes - bytes_written );
-		return_value = -1;
+    /* Store the data in a buffer instead of writing to file each time */
+	for( i = 0 ; i < nbytes ; i++)
+	{
+		WritetoFileBuffer[bytes_written_to_buffer++] = packetBuf[i];
+		
+	}
+	
+    /* Write to file only if available data exceeds 65536 */
+	if (bytes_written_to_buffer >= 65536 )
+	{
+		/* fd_md_txt is a global file descriptor which is set in the function  log_to_device */
+		bytes_written_to_file = write(fd_md_txt, WritetoFileBuffer, bytes_written_to_buffer);
+	    if( bytes_written_to_buffer !=  bytes_written_to_file )
+	    {
+			DIAG_LOGE(" Error : %d number of bytes not written to file: ", nbytes - bytes_written_to_file);
+			return_value = -1;
+	    }
+	    #ifdef EXTRA_DEBUGGING_PRINTS	       
+			DIAG_LOGE("DEBUG : %d Written to file \n", bytes_written_to_buffer);		
+		#endif /* EXTRA_DEBUGGING_PRINTS */	
+	    bytes_written_to_buffer = 0;
+	    
     }
-    
+        
     if ( printToTerminalFlag == TRUE )
     {
-		DIAG_LOGE(write2FileBuf);
+		DIAG_LOGE(packetBuf);
 	}
 
 	return return_value ;	
@@ -849,14 +1049,14 @@ int WriteToTextFile( unsigned char* ptr, int len )
 	unsigned char* header;  /* starting address of valid packet */
 	int numArgs;
 	
-	char       timestampString[120];   /* buffer tos save the sting in 1980-01-06 00:58:56.478 format */
+	char timestampString[120]= "";   /* buffer to save the string in 1980-01-06 00:58:56.478 format */
 	long long int msCounter;         
     int chipCounter , chipCounterMicroSeconds;
     long long int seconds, microSeconds;
-	time_t     timestamp_time_t;
+
     struct tm  timestamp_tm;    
     char temp_char_buf[20];
-    strcpy(timestampString,"");
+    
 	
 	unsigned int lineNumber;
 	
@@ -867,17 +1067,18 @@ int WriteToTextFile( unsigned char* ptr, int len )
 	
 	
 	int pktLen;    		
-	const char write2FileBuf[1000];
-    strcpy(write2FileBuf, "");    
-    int payLoadValues[MAX_MESSAGE_ARGUMENTS], payLoadNumValues = 0;
+	char write2FileBuf[1000] = "";   
+    int payLoadValues[MAX_MESSAGE_ARGUMENTS];
      
     
+    record_and_print_time("HDLC Decoder Start",0,1);
     HDLCDecoder( ptr, len );
-   
+    record_and_print_time("HDLC Decoder End",0,0);
           
 	if( decodedLen == -1 )
 		return -1;
 
+    record_and_print_time("Log Parsing Start",0 ,0);
 	/* traverse through hdlc decoded buffer to find 0x79 which extended debug message of QXDM
 	 * After which extract information from the buffer
 	*/
@@ -890,10 +1091,25 @@ int WriteToTextFile( unsigned char* ptr, int len )
 			continue;
 		}
 	
-		if( indexDF + 20 > decodedLen ) break; // not enough header.
-		
+		if( indexDF + 20 > decodedLen ) // not enough header
+		{
+		    #ifdef EXTRA_DEBUGGING_PRINTS
+				DIAG_LOGE("Not enough header : Saving bytes for next frame : Extra = %d , indexDF = %d , decodedLen =%d , len = %d , pktLen = %d \n", ( decodedLen - indexDF ) , indexDF, decodedLen, len, pktLen );
+			#endif 	
+			indexExtraByte = 0 ; /* j traverse from start of DecodedFrame to save pending bytes */
+			while( indexDF < decodedLen )
+			{
+				DecodedFrame[indexExtraByte++] = DecodedFrame[indexDF++]; 
+			}
+			decodedLen = indexExtraByte; 
+			break;
+	    }
+	
+		record_and_print_time("Log Packet BEG",0,1);	
 		/*Extract message */
 		header = &DecodedFrame[indexDF];
+		
+			
 		numArgs = header[2]; // the 3rd byte is the count of args.			
 		payload = header + 20;
 		fmtString = payload + numArgs*4;
@@ -913,8 +1129,8 @@ int WriteToTextFile( unsigned char* ptr, int len )
 		*/
 		msCounter = 0;		
 		chipCounter = 0;
-			chipCounter = header[4] ;               /* I got all chipCounter value = 0 in my testing. But still using it to actual time calculation */
-			chipCounter |= header[5] << 8 ;
+		chipCounter = header[4] ;               /* I got all chipCounter value = 0 in my testing. But still using it to actual time calculation */
+		chipCounter |= header[5] << 8 ;
 		
 		/* The 1/32 chip counter has 1.25 ms dynamic range. It rolls over at count 49152. Each tick  1.25 / 49152 =  0.000025431 ms */
 		chipCounterMicroSeconds = 	round(chipCounter * 0.000025431);
@@ -933,7 +1149,7 @@ int WriteToTextFile( unsigned char* ptr, int len )
 		
 			
 	    
-		seconds = seconds + (10*365+5+2)*24*60*60; /*total seconds since epoch after adding offset of Jan 6, 1980 */
+		seconds = seconds + 315964800  ;     /* (10*365+5+2)*24*60*60 : total seconds since epoch after adding offset of Jan 6, 1980 */
 
 		timestamp_tm = *localtime(&seconds);   /* Convert from seconds to 1980-01-06 00:58:56.478 format */ 
 		strcpy(timestampString,"");		
@@ -942,49 +1158,74 @@ int WriteToTextFile( unsigned char* ptr, int len )
         strcat( timestampString,temp_char_buf);
         //printf("time = %s\n", timestampString);
 
-		
+	
 		frameCRC = fileName + strlen( (char*)fileName ) + 1;
-		pktLen = 20 + numArgs*4 + strlen( (char*)fmtString ) + 1 + strlen( fileName ) + 1 + 3;
+		pktLen = 20 + numArgs*4 + strlen( (char*)fmtString ) + 1 + strlen((char*) fileName ) + 1 + 3;
 		
-            
-        if( header[3] != 0 ) // the 4rd byte is the count of missed packets
+	    
+	    if( header[3] != 0 ) // the 4rd byte is the count of missed packets
 		{			
-			//DIAG_LOGE("Warning! [%d] qxdm packets dropped\n", header[3] );
-			sprintf(write2FileBuf, "Warning! [%d] qxdm packets dropped \n", header[3] );
+			DIAG_LOGE("%s : Warning! [%d] qxdm packets dropped\n", timestampString, header[3] );
+			sprintf(write2FileBuf, "%s : Warning! [%d] qxdm packets dropped \n", timestampString , header[3] );			
+			//DumpFrame(&header[0], 200);
 			PrintToTxtFile( write2FileBuf );			
+		}    
+		
+ #ifdef EXTRA_DEBUGGING_PRINTS     
+        if ( numArgs > 6 )
+        {
+			DIAG_LOGE(" num Args = %d :indexDF = %d , decodedLen =%d , len = %d , pktLen = %d  indexExtraByte = %d\n",numArgs ,indexDF, decodedLen, len, pktLen , indexExtraByte );
 		}
-
+ #endif
+    
 		if (fmtString != NULL )		
 		{								
 			/* Check if the complete packet is in the current frame else save bytes to be concatenate with the start of next frame */	
 			if ( pktLen > ( decodedLen - indexDF ) )
 			{	
-				
-				//DIAG_LOGE(" Saving bytes for next frame :i = %d , decodedLen =%d , len = %d , pktLen = %d \n",i, decodedLen, len, pktLen );
+				//DumpFrame( DecodedFrame[indexDF] , 15 );
+				#ifdef EXTRA_DEBUGGING_PRINTS
+					DIAG_LOGE(" Incomplete packet: Saving bytes for next frame : Extra = %d , indexDF = %d , decodedLen =%d , len = %d , pktLen = %d \n", ( decodedLen - indexDF ) , indexDF, decodedLen, len, pktLen );
+				#endif 	
 				indexExtraByte = 0 ; /* j traverse from start of DecodedFrame to save pending bytes */
 				while( indexDF < decodedLen )
 				{
 					DecodedFrame[indexExtraByte++] = DecodedFrame[indexDF++]; 
 				}
-				decodedLen = indexExtraByte ; 
+				decodedLen = indexExtraByte; 
 				break;										
 				
 				
 			}
 			else 
 			{	
+				record_and_print_time("D-P-load S",0,0);
 				DecodePayload( payload, payLoadValues , numArgs );
+				record_and_print_time("D-P-load E",0,0);
+				
+				record_and_print_time("G W2Buf S",0,0);
 				GenerateWrite2FileBuf( write2FileBuf , timestampString , fileName , lineNumber , fmtString , payLoadValues , numArgs , header ); 
-				PrintToTxtFile( write2FileBuf ); 				              				
+				record_and_print_time("G W2Buf E",0,0);
+				
+				record_and_print_time("P2file S",0,0);
+				PrintToTxtFile( write2FileBuf );
+				record_and_print_time("P2file E",0,0); 				              				
 			}
 			//DIAG_LOGE( "DecodedFrame: pktLen[%d] args[%d] fmtStr[%s] fileName[%s]\n", pktLen, numArgs, fmtString, fileName );
 		}
+
+
 		indexDF += pktLen;
+		
+		record_and_print_time("Log Packet End",0,0);
 	}
+	record_and_print_time("Log Parsing End",0,0);
 	
-	//DIAG_LOGE(" Debug End of buffer :i = %d , decodedLen =%d , len = %d , pktLen = %d  j = %d\n",i, decodedLen, len, pktLen , j );
-		
-	/* No bytes will be reused in the next frame if j = 0 */
+#ifdef EXTRA_DEBUGGING_PRINTS	
+	DIAG_LOGE(" Debug End of buffer :indexDF = %d , decodedLen =%d , len = %d , pktLen = %d  indexExtraByte = %d\n",indexDF, decodedLen, len, pktLen , indexExtraByte );
+#endif		
+
+	/* No bytes will be reused in the next frame if indexExtraByte = 0 */
 	if ( indexExtraByte == 0 )
 	{
 	   decodedLen = 0 ;		 	
@@ -1021,7 +1262,7 @@ DEPENDENCIES
 void enable_write_to_terminal( int terminalFlag )
 {
 	 
-	printToTerminalFlag = terminalFlag;
+		printToTerminalFlag = terminalFlag;
 	
 }
 
@@ -1039,6 +1280,10 @@ void log_to_device(unsigned char *ptr, int logging_mode, int size)
 	int status;
 	int bytes_remaining;
 	unsigned char *sock_ptr;
+	
+	
+     
+    
 
 	ptr += 4;
 	if (fd_dev < 0) {
@@ -1087,11 +1332,16 @@ void log_to_device(unsigned char *ptr, int logging_mode, int size)
 			ret = write(fd_dev, (const void*) base_ptr, size);
 			
 			
+			
 			if ( printToTxtFileFlag == TRUE )					
 			{	
+				record_and_print_time("Begin WriteToTextFile",1 ,0);
 				WriteToTextFile(base_ptr,size);
+				record_and_print_time("End WriteToTextFile",0 , 0);
+				
 			}
 			
+			
 			if ( ret > 0) {
 				count_written_bytes += size;
 			}else {
@@ -1300,6 +1550,9 @@ void diag_switch_logging(int mode, char *dir_location)
 			close(fd_md);
 			fd_md = -1;
 			fd_dev = fd_md;
+			
+			fd_md_txt = -1;
+			fd_dev_txt = -1;
 			count_written_bytes = 0;
 		}
 		logging_mode = mode;
@@ -1370,6 +1623,10 @@ SIDE EFFECTS
 
 boolean Diag_LSM_Init (byte* pIEnv)
 {
+#ifdef INCREASE_NUM_BUFFER
+	int i;
+#endif
+
 #ifdef FEATURE_WINMOB
    DWORD dwGetModule = 0;
    TCHAR FileName[MAX_PATH];
@@ -1405,6 +1662,34 @@ boolean Diag_LSM_Init (byte* pIEnv)
       }
 
 #ifndef FEATURE_WINMOB
+
+#ifdef INCREASE_NUM_BUFFER
+
+    write_in_progress = 0;
+	in_read = 0;
+	
+    curr_write = 0 ;
+    curr_read = 0; 
+	/* $SSC Init function for buffer pool over here	 */
+	initialize_buffer_pool();
+	
+	for ( i = 0 ; i < NUMBER_OF_BUFFERS ; i++)
+	{
+		pools[i].free = 1;
+		pools[i].data_ready = 0;
+	}
+
+
+	for ( i = 0; i < NUMBER_OF_BUFFERS ; i++)
+	{
+		pthread_mutex_init(&(pools[i].write_mutex), NULL);
+		pthread_cond_init(&(pools[i].write_cond), NULL);
+		pthread_mutex_init(&(pools[i].read_mutex), NULL);
+		pthread_cond_init(&(pools[i].read_cond), NULL);		
+	}
+
+
+#else
       pthread_mutex_init(&(pools[0].write_mutex), NULL);
       pthread_cond_init(&(pools[0].write_cond), NULL);
       pthread_mutex_init(&(pools[0].read_mutex), NULL);
@@ -1413,9 +1698,10 @@ boolean Diag_LSM_Init (byte* pIEnv)
       pthread_cond_init(&(pools[1].write_cond), NULL);
       pthread_mutex_init(&(pools[1].read_mutex), NULL);
       pthread_cond_init(&(pools[1].read_cond), NULL);
+      
+#endif
       pthread_mutex_init(&stop_mutex, NULL);
-      pthread_cond_init(&stop_cond, NULL);
-
+      pthread_cond_init(&stop_cond, NULL);	
       /* Creating read thread which listens for various masks & pkt
        * requests
        */
@@ -1535,6 +1821,8 @@ static void *CreateWaitThread(void* param)
 
 				DIAG_LOGE(" %s exitting ...[%d]..\n",
 						__func__, curr_read);
+						
+						
 				pools[curr_read].data_ready = 1;
 				pools[curr_read].free = 0;
 				pools[curr_read].buffer_ptr =
@@ -1549,7 +1837,19 @@ static void *CreateWaitThread(void* param)
 						&pools[curr_read].write_cond);
 				pthread_mutex_unlock(
 					&pools[curr_read].write_mutex);
-				curr_read != curr_read;
+				
+				#ifdef INCREASE_NUM_BUFFER
+					curr_read++;
+					if (curr_read >= NUMBER_OF_BUFFERS )
+					{
+						curr_read = 0;	
+					}
+				#else
+					curr_read != curr_read;
+				#endif	
+				
+				
+				
 				/* As cleanup started now wait for cleanup to
 				 * complete.
 				 */
@@ -1565,9 +1865,17 @@ static void *CreateWaitThread(void* param)
 							READ_BUF_SIZE);
 
 				in_read = 0;
-				if((*(int *)read_buffer == DEINIT_TYPE) ||
-							(num_bytes_read < 0))
-				break;
+				if((*(int *)read_buffer == DEINIT_TYPE) || (num_bytes_read < 0))
+				{					
+				  break;
+				  #ifdef INCREASE_NUM_BUFFER
+					//usleep(500000);
+				  #endif
+				}
+				
+				
+				
+					
 				process_diag_payload();
 			}
 		}while(1);
