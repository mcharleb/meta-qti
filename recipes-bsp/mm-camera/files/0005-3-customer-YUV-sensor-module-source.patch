diff --git a/server/hardware/sensor/cust_sens/cust_sens_params.conf b/server/hardware/sensor/cust_sens/cust_sens_params.conf
new file mode 100644
index 0000000..f54a739
--- /dev/null
+++ b/server/hardware/sensor/cust_sens/cust_sens_params.conf
@@ -0,0 +1,3 @@
+CSID_LANE_CNT=2
+CSIPHY_LANE_CNT=2
+CSIPHY_SETTLE_CNT=0x6
diff --git a/server/hardware/sensor/cust_sens/cust_sens_u.c b/server/hardware/sensor/cust_sens/cust_sens_u.c
new file mode 100644
index 0000000..ecca151
--- /dev/null
+++ b/server/hardware/sensor/cust_sens/cust_sens_u.c
@@ -0,0 +1,247 @@
+/*==========================================================================
+
+   Copyright (c) 2014 QUALCOMM Technologies Incorporated.  All Rights Reserved.
+   QUALCOMM Proprietary and Confidential.
+
+==============================================================================
+
+/[SENSOR]
+Sensor Model:   cust_sens
+Camera Module:
+Lens Model:
+Driver IC:
+PV Size         = 640 x 480
+Cap Size        = 2592 x 1944
+Output Format   = YUYV
+MCLK Speed      = 24M
+PV DVP_PCLK     = 28M
+Cap DVP_PCLK    = 56M
+PV Frame Rate   = 30fps
+Cap Frame Rate  = 7.5fps
+I2C Slave ID    = 0x78
+I2C Mode        = 16Addr, 8Data
+*/
+
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <dlfcn.h>  
+#include "camera_dbg.h"
+#include "sensor_util.h"
+#include "cust_sens_u.h"
+/*============================================================================
+                        EXTERNAL VARIABLES DECLARATIONS
+============================================================================*/
+/* r/w copy of chromatix data. Must be initialized with
+ * active sensor chromatix data everytime camera is started.
+ */
+/* Sensor model number used in camear for this sensor */
+#define SENSOR_MODEL_NO_CUST_SENS "cust_sens"
+#define CUST_SENS_LOAD_CHROMATIX(n) \
+  "libchromatix_"SENSOR_MODEL_NO_CUST_SENS"_"#n".so"
+
+const char *error_str;
+uint8_t get_csid_lane_cnt(void)
+{
+	void* lib_csidparameter_handle =  NULL;
+	typedef int (*fncptr_csid_parameters)();
+	fncptr_csid_parameters  ptr_csid_parameters = NULL;
+	lib_csidparameter_handle = NULL;
+
+	lib_csidparameter_handle =  dlopen("libcustcamsens_params.so", RTLD_NOW);
+	if (!lib_csidparameter_handle) {
+        	LOGE("failed to load mmcamera_csid_params library");
+    	}
+	else {
+       		ptr_csid_parameters = (fncptr_csid_parameters)dlsym(lib_csidparameter_handle, "load_csid_parameters");
+       		if ((error_str = dlerror()) != NULL)
+           		LOGE("%s", error_str);
+
+    		if (!ptr_csid_parameters) {
+         		LOGE("failed to get load_csi_parameters function address");
+      		}
+
+   	}
+	dlclose(lib_csidparameter_handle);
+	return csid_lane_count;
+}
+uint8_t get_csiphy_lane_cnt(void)
+{
+        void* lib_csiphyparameter_handle =  NULL;
+        typedef int (*fncptr_csiphy_parameters)();
+        fncptr_csiphy_parameters  ptr_csiphy_parameters = NULL;
+        lib_csiphyparameter_handle = NULL;
+        lib_csiphyparameter_handle =  dlopen("libcustcamsens_params.so", RTLD_NOW);
+        if (!lib_csiphyparameter_handle) {
+                LOGE("failed to load mmcamera_csiphy_params library");
+        }
+        else {
+                ptr_csiphy_parameters = (fncptr_csiphy_parameters)dlsym(lib_csiphyparameter_handle, "load_csiphy_parameters");
+                if ((error_str = dlerror()) != NULL)
+                        LOGE("%s", error_str);
+
+                if (!ptr_csiphy_parameters) {
+                        LOGE("failed to get load_csi_parameters function address");
+                }
+
+        }
+	dlclose(lib_csiphyparameter_handle);
+       return csiphy_lane_count;
+}
+uint8_t get_csiphy_settle_cnt()
+{
+	void* lib_csiphy_settlecnt_parameter_handle =  NULL;
+        typedef int (*fncptr_csiphy_settlecnt_parameters)();
+        fncptr_csiphy_settlecnt_parameters  ptr_csiphy_settlecnt_parameters = NULL;
+        lib_csiphy_settlecnt_parameter_handle = NULL;
+        lib_csiphy_settlecnt_parameter_handle =  dlopen("libcustcamsens_params.so", RTLD_NOW);
+        if (!lib_csiphy_settlecnt_parameter_handle) {
+                LOGE("failed to load mmcamera_csiphy_params library");
+        }
+        else {
+                ptr_csiphy_settlecnt_parameters = (fncptr_csiphy_settlecnt_parameters)dlsym(lib_csiphy_settlecnt_parameter_handle, "load_csiphy_settlecnt_parameters");
+                if ((error_str = dlerror()) != NULL)
+                        LOGE("%s", error_str);
+
+                if (!ptr_csiphy_settlecnt_parameters) {
+                        LOGE("failed to get load_csi_parameters function address");
+                }
+
+        }
+	dlclose(lib_csiphy_settlecnt_parameter_handle);
+        return csiphy_settle_count;
+}
+
+
+/* Types of shared object available for this sensor to load dynamically */
+char *cust_sens_load_chromatix[SENSOR_LOAD_CHROMATIX_MAX] = {
+  NULL, /* camera / camcorder preview */
+  NULL, /* Non HD Video recording */
+  NULL, /* HD video recording */
+  NULL, /* HFR 60 fps video recording */
+  NULL, /* HFR 90 fps video recording */
+  NULL, /* HFR 120 fps video recording */
+  NULL, /* HFR 150 fps video recording */
+  NULL, /* AR */
+  NULL, /* ZSL */
+};
+
+static struct msm_camera_csid_vc_cfg cust_sens_cid_cfg[] = {
+  {0, CSI_YUV422_8, CSI_DECODE_8BIT},
+//  {1, CSI_EMBED_DATA, CSI_DECODE_8BIT},
+};
+static struct msm_camera_csi2_params cust_sens_csi_params = {
+  .csid_params = {
+    .lane_cnt =  0,
+    .lut_params = {
+      .num_cid = ARRAY_SIZE(cust_sens_cid_cfg),
+      .vc_cfg = cust_sens_cid_cfg,
+    },
+  },
+  .csiphy_params = {
+    .lane_cnt = 0,
+    .settle_cnt = 0x1, //0x14, // /* 0x1B, - perfect vfe getting value. */
+  },
+};
+
+
+static struct msm_camera_csi2_params *cust_sens_csi_params_array[] = {
+  &cust_sens_csi_params,/*FULL*/
+  &cust_sens_csi_params,/*QTR*/
+};
+
+/*****************************************************************************
+ *                          RUN TIME VARIABLES
+ ****************************************************************************/
+
+static sensor_camif_inputformat_t cust_sens_inputformat[] = {
+//    CAMIF_YCBCR_Y_CB_Y_CR,/*RES0*/
+//    CAMIF_YCBCR_Y_CB_Y_CR,/*RES1*/
+//mt9m114 below
+    CAMIF_YCBCR_CB_Y_CR_Y,/*RES0*/
+    CAMIF_YCBCR_CB_Y_CR_Y,/*RES1*/
+};
+
+static sensor_crop_parms_t cust_sens_cropinfo[] = {
+/*top, down, left, right*/
+#if VFE_31
+  {24, 24, 56, 56},/*FULL*/
+  {12, 12, 28, 28},/*QTR*/
+#else
+  {0, 0, 0, 0},/*FULL*/
+  {0, 0, 0, 0},/*QTR*/
+#endif
+};
+
+#if 0
+static uint32_t cust_sens_mode_res[SENSOR_MODE_INVALID] = {
+  MSM_SENSOR_RES_FULL,/*SENSOR_MODE_SNAPSHOT*/
+  MSM_SENSOR_RES_FULL,/*SENSOR_MODE_RAW_SNAPSHOT*/
+  MSM_SENSOR_RES_FULL,/*SENSOR_MODE_PREVIEW*/
+  MSM_SENSOR_RES_FULL,/*SENSOR_MODE_VIDEO*/
+  MSM_SENSOR_RES_FULL,/*SENSOR_MODE_VIDEO_HD*/
+  MSM_SENSOR_INVALID_RES,/*SENSOR_MODE_HFR_60FPS*/
+  MSM_SENSOR_INVALID_RES,/*SENSOR_MODE_HFR_90FPS*/
+  MSM_SENSOR_INVALID_RES,/*SENSOR_MODE_HFR_120FPS*/
+  MSM_SENSOR_INVALID_RES,/*SENSOR_MODE_HFR_150FPS*/
+  MSM_SENSOR_RES_FULL,/*SENSOR_MODE_ZSL*/
+};
+#endif
+
+static uint32_t cust_sens_mode_res[SENSOR_MODE_INVALID] = {
+  MSM_SENSOR_RES_FULL,/*SENSOR_MODE_SNAPSHOT*/
+  MSM_SENSOR_RES_QTR,/*SENSOR_MODE_PREVIEW*/
+};
+
+static sensor_function_table_t cust_sens_func_tbl = {
+  .sensor_set_op_mode = sensor_util_set_op_mode,
+//  .sensor_get_mode_aec_info = sensor_util_get_mode_aec_info,
+  .sensor_get_dim_info = sensor_util_get_dim_info,
+  .sensor_get_preview_fps_range = sensor_util_get_preview_fps_range,
+  .sensor_get_snapshot_fps = sensor_util_get_snapshot_fps,
+//  .sensor_get_max_supported_hfr_mode = sensor_util_get_max_supported_hfr_mode,
+  .sensor_get_lens_info = sensor_get_lens_info,
+  .sensor_set_start_stream = sensor_util_set_start_stream,
+  .sensor_set_stop_stream = sensor_util_set_stop_stream,
+  .sensor_get_csi_params = sensor_util_get_csi_params,
+};
+
+int8_t cust_sens_process_start(void *ctrl)
+{
+  sensor_ctrl_t *sctrl = (sensor_ctrl_t *) ctrl;
+  sctrl->fn_table = &cust_sens_func_tbl;
+  sctrl->sensor.inputformat = cust_sens_inputformat;
+  sctrl->sensor.crop_info = cust_sens_cropinfo;
+  sctrl->sensor.mode_res = cust_sens_mode_res;
+  sctrl->sensor.sensor_csi_params.csi2_params = &cust_sens_csi_params_array[0];
+LOGE("##############before get_csid_lane_cnt call csid lane cnt = %d",(*(sctrl->sensor.sensor_csi_params.csi2_params))->csid_params.lane_cnt); 
+LOGE("##############befor get_csiphy_lane_cnt call csiphy lane cnt = %d",(*(sctrl->sensor.sensor_csi_params.csi2_params))->csiphy_params.lane_cnt);
+LOGE("##############before get_csiphy_settle_cnt call csiphy settle cnt = 0x%x",(*(sctrl->sensor.sensor_csi_params.csi2_params))->csiphy_params.settle_cnt);
+
+  (*(sctrl->sensor.sensor_csi_params.csi2_params))->csid_params.lane_cnt =  get_csid_lane_cnt(); 
+  (*(sctrl->sensor.sensor_csi_params.csi2_params))->csiphy_params.lane_cnt =  get_csiphy_lane_cnt();
+  (*(sctrl->sensor.sensor_csi_params.csi2_params))->csiphy_params.settle_cnt =  get_csiphy_settle_cnt();
+
+LOGE("##############csid lane cnt = %d",(*(sctrl->sensor.sensor_csi_params.csi2_params))->csid_params.lane_cnt); 
+LOGE("##############csiphy lane cnt = %d",(*(sctrl->sensor.sensor_csi_params.csi2_params))->csiphy_params.lane_cnt);
+LOGE("##############csiphy settle cnt = 0x%x",(*(sctrl->sensor.sensor_csi_params.csi2_params))->csiphy_params.settle_cnt);
+  sensor_util_get_output_info(sctrl);
+  sctrl->sensor.op_mode = SENSOR_MODE_VIDEO;
+
+  sctrl->sensor.out_data.sensor_output.connection_mode = SENSOR_MIPI_CSI;
+  sctrl->sensor.out_data.sensor_output.output_format = SENSOR_YCBCR;
+  sctrl->sensor.out_data.sensor_output.raw_output = SENSOR_8_BIT_DIRECT;
+
+  sctrl->sensor.out_data.lens_info.focal_length = 4.6;
+  sctrl->sensor.out_data.lens_info.pix_size = 1.4;
+  sctrl->sensor.out_data.lens_info.f_number = 2.65;
+  sctrl->sensor.out_data.lens_info.total_f_dist = 1.97;
+  sctrl->sensor.out_data.lens_info.hor_view_angle = 54.8;
+  sctrl->sensor.out_data.lens_info.ver_view_angle = 42.5;
+
+  sensor_util_config(sctrl);
+  return TRUE;
+}
diff --git a/server/hardware/sensor/cust_sens/cust_sens_u.h b/server/hardware/sensor/cust_sens/cust_sens_u.h
new file mode 100644
index 0000000..ed3705b
--- /dev/null
+++ b/server/hardware/sensor/cust_sens/cust_sens_u.h
@@ -0,0 +1,16 @@
+/*============================================================================
++
++   Copyright (c) 2011 QUALCOMM Technologies Incorporated.  All Rights Reserved.
++   QUALCOMM Proprietary and Confidential.
++
+============================================================================*/
+#ifndef _CUST_SENS__
+#define _CUST_SENS__
+
+#include "sensor.h"
+extern uint8_t  csid_lane_count;
+extern uint8_t  csiphy_lane_count;
+extern uint8_t  csiphy_settle_count;
+
+int8_t cust_sens_process_start(void *ctrl);
+#endif
diff --git a/server/hardware/sensor/cust_sens/libcustcamsens_params.c b/server/hardware/sensor/cust_sens/libcustcamsens_params.c
new file mode 100644
index 0000000..c5a35de
--- /dev/null
+++ b/server/hardware/sensor/cust_sens/libcustcamsens_params.c
@@ -0,0 +1,99 @@
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#define CSI_PARAMS_FILE "/etc/cust_sens_params.conf"
+#define MAX_LINE_LENGTH 80
+#define CSID_LANE_COUNT "CSID_LANE_CNT="
+#define CSIPHY_LANE_COUNT "CSIPHY_LANE_CNT="
+#define CSIPHY_SETTLE_COUNT "CSIPHY_SETTLE_CNT=0x"
+
+#define DEFAULT_LANE_COUNT 2
+#define DEFAULT_SETTLE_COUNT 0x6
+
+/*static unsigned int csid_lane_count= DEFAULT_LANE_COUNT;
+static unsigned int csiphy_lane_count= DEFAULT_LANE_COUNT;
+static unsigned int csiphy_settle_count= DEFAULT_SETTLE_COUNT;*/
+ uint8_t  csid_lane_count= DEFAULT_LANE_COUNT;
+ uint8_t  csiphy_lane_count= DEFAULT_LANE_COUNT;
+ uint8_t  csiphy_settle_count= DEFAULT_SETTLE_COUNT;
+
+uint8_t load_csid_parameters()
+{
+char lane[MAX_LINE_LENGTH];
+char count[2];
+FILE *fp;
+
+  fp = fopen(CSI_PARAMS_FILE, "r");
+  if(!fp)
+    return -1;
+  while(fgets(lane, MAX_LINE_LENGTH, fp))
+   {
+        if(!strncmp(lane, CSID_LANE_COUNT, strlen(CSID_LANE_COUNT)))
+        {
+                count[0] = lane[strlen(CSID_LANE_COUNT)];
+                count[1] = '\0';
+       if(isdigit(count[0]))
+        {
+                 csid_lane_count = atoi(count);
+                 break;
+        }
+        }
+   }
+   fclose(fp);
+return csid_lane_count; 
+}
+
+uint8_t load_csiphy_parameters()
+{
+char lane[MAX_LINE_LENGTH];
+char count[2];
+FILE *fp;
+
+  fp = fopen(CSI_PARAMS_FILE, "r");
+  if(!fp)
+    return -1 ;
+  while(fgets(lane, MAX_LINE_LENGTH, fp))
+   {
+        if(!strncmp(lane, CSIPHY_LANE_COUNT, strlen(CSIPHY_LANE_COUNT)))
+        {
+                count[0] = lane[strlen(CSIPHY_LANE_COUNT)];
+                count[1] = '\0';
+        if(isdigit(count[0]))
+        {
+                 csiphy_lane_count = atoi(count);
+                 break;
+        }
+        }
+   }
+   fclose(fp);
+return csiphy_lane_count;
+}
+
+uint8_t  load_csiphy_settlecnt_parameters()
+{
+char settle[MAX_LINE_LENGTH];
+char count[2];
+FILE *fp;
+
+  fp = fopen(CSI_PARAMS_FILE, "r");
+  if(!fp)
+    return -1;
+  while(fgets(settle, MAX_LINE_LENGTH, fp))
+   {
+        if(!strncmp(settle, CSIPHY_SETTLE_COUNT, strlen(CSIPHY_SETTLE_COUNT)))
+        {
+                count[0] = settle[strlen(CSIPHY_SETTLE_COUNT)];
+                count[1] = '\0';
+        if(isdigit(count[0]))
+        {
+                 csiphy_settle_count = atoi(count);
+                 break;
+        }
+        }
+   }
+   fclose(fp);
+return csiphy_settle_count;
+}
diff --git a/server/hardware/sensor/sensor.c b/server/hardware/sensor/sensor.c
index 4e38128..ca39bb4 100644
--- a/server/hardware/sensor/sensor.c
+++ b/server/hardware/sensor/sensor.c
@@ -31,6 +31,7 @@
   #include "ov2720_u.h"
   #include "imx074_u.h"
   #include "mt9m114_u.h"
+  #include "cust_sens_u.h"	
   #include "s5k3l1yx_u.h"
   #include "imx091_u.h"
   #include "imx135_u.h"
@@ -72,6 +73,7 @@
 extern char *ov2720_load_chromatix[];
 extern char *imx074_load_chromatix[];
 extern char *mt9m114_load_chromatix[];
+extern char *cust_sens_load_chromatix[];
 extern char *s5k3l1yx_load_chromatix[];
 extern char *vx6953_load_chromatix[];
 extern char *s5k4e1_load_chromatix[];
@@ -102,6 +104,7 @@ static sensor_proc_start_t sensors[] = {
   SENSORS_PROCCESS_START(ov2720),
   SENSORS_PROCCESS_START(imx074),
   SENSORS_PROCCESS_START(mt9m114),
+  SENSORS_PROCCESS_START(cust_sens),
   SENSORS_PROCCESS_START(s5k3l1yx),
   SENSORS_PROCCESS_START(imx135),
   SENSORS_PROCCESS_START(ov8825),
