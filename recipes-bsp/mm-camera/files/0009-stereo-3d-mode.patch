diff --git a/apps/appslib/camframe.c b/apps/appslib/camframe.c
index 8404216..d0d9513 100644
--- a/apps/appslib/camframe.c
+++ b/apps/appslib/camframe.c
@@ -670,16 +670,16 @@ void *cam_frame_v4l2(void *data)
       num_fds = 1;
     retval = poll(fds2, num_fds, timeoutms);
 
-    CDBG("cam_frame_v4l2: select rc = 0x%x\n", retval);
+    /*CDBG("cam_frame_v4l2: select rc = 0x%x\n", retval);
     CDBG("cam_frame_v4l2: poll fd0 return revents:0x%x\n",
       fds2[0].revents);
     if(num_fds == 2) {
       CDBG("cam_frame_v4l2: poll fd1 return revents:0x%x\n",
         fds2[1].revents);
-    }
+    }*/
     if (retval == 0) {
       if (camframe_v4l2_exit != 0) {
-        CDBG("cam_frame: exit 1\n");
+        /*CDBG("cam_frame: exit 1\n");*/
         break;
       }
       usleep(1000 * 100);
@@ -924,7 +924,7 @@ void *cam_frame_v4l2(void *data)
         }/*if ((fds[1].revents & POLLIN) && (fds[1].revents & POLLRDNORM)) */
       }
     } /*else if (retval) */
-    CDBG("%s exit flag = %d\n", __func__, camframe_v4l2_exit);
+    /*CDBG("%s exit flag = %d\n", __func__, camframe_v4l2_exit);*/
   } while (camframe_v4l2_exit == 0);
 done2:
   close(terminatefd[0]);
diff --git a/server/core/config/config_proc_ctrlcmd.c b/server/core/config/config_proc_ctrlcmd.c
index d667f29..06d442d 100644
--- a/server/core/config/config_proc_ctrlcmd.c
+++ b/server/core/config/config_proc_ctrlcmd.c
@@ -4442,7 +4442,7 @@ static int8_t config_proc_CAMERA_GET_CAPABILITIES(void *parm1, void *parm2)
   prop->max_video_width = sensor_get.data.sensor_dim.width;
   prop->max_video_height = sensor_get.data.sensor_dim.height;
 
-  sensor_get.data.sensor_dim.op_mode = SENSOR_MODE_VIDEO_HDR;
+  sensor_get.data.sensor_dim.op_mode = SENSOR_MODE_VIDEO;
    rc = ctrl->comp_ops[MCTL_COMPID_SENSOR].get_params(
       ctrl->comp_ops[MCTL_COMPID_SENSOR].handle,
       SENSOR_GET_DIM_INFO, &sensor_get, sizeof(sensor_get));
@@ -4484,6 +4484,7 @@ static int8_t config_proc_CAMERA_GET_CAPABILITIES(void *parm1, void *parm2)
   prop->yuv_thru_vfe = ctrl->yuv_thru_vfe;
 
   ctrlCmd->status =  CAM_CTRL_SUCCESS;
+  CDBG("config_proc_CAMERA_GET_CAPABILITIES exit \n"); 
   return TRUE;
 }
 
diff --git a/server/core/mctl/mctl.c b/server/core/mctl/mctl.c
index 4f3d090..8814b8c 100644
--- a/server/core/mctl/mctl.c
+++ b/server/core/mctl/mctl.c
@@ -373,6 +373,7 @@ static int mctl_load_stats_proc_lib(void)
 }
 
 /* initialize a media contoller itself - opposite to mctl_release() */
+extern void sensor_dump_csi_params(sensor_csi_params_t  *csi_param);
 static int mctl_init_comps(mctl_config_ctrl_t* p_cfg_ctrl, uint32_t comp_mask)
 {
   int rc = 0;
@@ -446,7 +447,25 @@ static int mctl_init_comps(mctl_config_ctrl_t* p_cfg_ctrl, uint32_t comp_mask)
     }
 
     csi_set_t csi_set;
-    csi_set.data.csi_params = sensor_get.data.sensor_csi_params;
+	int i =0;
+	if(sensor_get.data.mode_3d) {
+        CDBG("%s: csi_set config sensor in 3d mode \n", __func__);
+    	csi_set.data.csi3d_params[0] = sensor_get.data.sensor_csi3d_params[0];
+    	csi_set.data.csi3d_params[1] = sensor_get.data.sensor_csi3d_params[1];
+    	csi_set.mode_3d = 1;
+  		for (i=0; i<2; i++) { 
+	  		CDBG("%s csi_params from sensor_get csi%d:\n",__func__, i);
+	    	sensor_dump_csi_params(sensor_get.data.sensor_csi3d_params[i]);
+		}	
+  		for (i=0; i<2; i++) { 
+	  		CDBG("%s csi_params to csi_set csi%d:\n",__func__, i);
+	    	sensor_dump_csi_params(csi_set.data.csi3d_params[i]);
+		}	
+	} else {
+        CDBG("%s: csi_set config sensor in non-3d mode \n", __func__);
+    	csi_set.data.csi_params = sensor_get.data.sensor_csi_params;
+    	csi_set.mode_3d = 0;
+	}
     rc = p_cfg_ctrl->comp_ops[MCTL_COMPID_CSI].set_params(
       p_cfg_ctrl->comp_ops[MCTL_COMPID_CSI].handle,
       CSI_SET_DATA, &csi_set, NULL);
diff --git a/server/hardware/csi/csi.h b/server/hardware/csi/csi.h
index e751746..4d03ca8 100644
--- a/server/hardware/csi/csi.h
+++ b/server/hardware/csi/csi.h
@@ -14,8 +14,11 @@ typedef struct {
   uint32_t fd;
   uint32_t csid_version;
   sensor_csi_params_t *csi_params;
+  sensor_csi_params_t *csi3d_params[2];
   struct msm_camera_csi_params *curr_csic_params;
   struct msm_camera_csi2_params *curr_csi2_params;
+  struct msm_camera_csi2_params *curr_csi2_3d_params[2];
+  uint8_t mode_3d;
 } csi_t;
 
 #define CSI_MAX_CLIENT_NUM 4
diff --git a/server/hardware/csi/csi2/csi.c b/server/hardware/csi/csi2/csi.c
index 3bd3924..0c50a97 100644
--- a/server/hardware/csi/csi2/csi.c
+++ b/server/hardware/csi/csi2/csi.c
@@ -54,20 +54,46 @@ ERROR:
 int csi_util_set_cfg(csi_t *csi_obj, csi_set_data_t *csi_set)
 {
   int rc = 0;
-  CDBG("%s curr csi2 params = %p, curr res = %d\n", __func__,
-    csi_obj->curr_csi2_params,
-    csi_set->res);
 
-  if(!csi_obj->csi_params->csi2_params) {
-    CDBG_ERROR("%s csi2_params NULL\n", __func__);
-    rc = -EINVAL;
-    goto ERROR;
-  }
-
-  if (csi_obj->csi_params->csi2_params[csi_set->res] ==
-       csi_obj->curr_csi2_params)
+  if(csi_obj->mode_3d) {
+  	CDBG("%s curr csi2_3d params = (%p) (%p), curr res = %d\n", __func__,
+    	csi_obj->curr_csi2_3d_params[0],
+    	csi_obj->curr_csi2_3d_params[1],
+    	csi_set->res);
+
+  	if(!csi_obj->csi3d_params[0]->csi2_params) {
+    	CDBG_ERROR("%s csi2_3d_params0 NULL\n", __func__);
+    	rc = -EINVAL;
+    	goto ERROR;
+  	}
+
+  	if(!csi_obj->csi3d_params[1]->csi2_params) {
+    	CDBG_ERROR("%s csi2_3d_params1 NULL\n", __func__);
+    	rc = -EINVAL;
+    	goto ERROR;
+  	}
+
+  	/*if (csi_obj->csi3d_params[0]->csi2_params[csi_set->res] ==
+       	csi_obj->curr_csi2_3d_params[0])
+    return 0;*/
+
+  } else {
+  	CDBG("%s curr csi2 params = %p, curr res = %d\n", __func__,
+    	csi_obj->curr_csi2_params,
+    	csi_set->res);
+
+  	if(!csi_obj->csi_params->csi2_params) {
+    	CDBG_ERROR("%s csi2_params NULL\n", __func__);
+    	rc = -EINVAL;
+    	goto ERROR;
+  	}
+
+  	if (csi_obj->csi_params->csi2_params[csi_set->res] ==
+       	csi_obj->curr_csi2_params)
     return 0;
 
+  } /* end mode_3d */
+
   rc = csid_set_cfg(csi_obj, csi_set->res);
   if(rc < 0) {
     CDBG_ERROR("%s line = %d, ERROR = %d\n", __func__, __LINE__, rc);
@@ -80,7 +106,12 @@ int csi_util_set_cfg(csi_t *csi_obj, csi_set_data_t *csi_set)
     goto ERROR;
   }
 
-  csi_obj->curr_csi2_params = csi_obj->csi_params->csi2_params[csi_set->res];
+  if(csi_obj->mode_3d) {
+  	csi_obj->curr_csi2_3d_params[0] = csi_obj->csi3d_params[0]->csi2_params[csi_set->res];
+  	csi_obj->curr_csi2_3d_params[1] = csi_obj->csi3d_params[1]->csi2_params[csi_set->res];
+  } else {
+  	csi_obj->curr_csi2_params = csi_obj->csi_params->csi2_params[csi_set->res];
+  }
 
 ERROR:
   return rc;
diff --git a/server/hardware/csi/csi2/csid/csid.c b/server/hardware/csi/csi2/csid/csid.c
index 66cf96a..5ba1ad5 100644
--- a/server/hardware/csi/csi2/csid/csid.c
+++ b/server/hardware/csi/csi2/csid/csid.c
@@ -19,17 +19,25 @@
 int csid_process_init(csi_t *csi_obj, uint32_t *csid_version)
 {
   int rc = 0;
+  int i =0;
+  int cfg_cnt=1;
   struct csid_cfg_data cfg;
 
-  cfg.cfgtype = CSID_INIT;
-  rc = ioctl(csi_obj->fd, MSM_CAM_IOCTL_CSID_IO_CFG, &cfg);
-  if (rc < 0) {
-    CDBG_ERROR("%s MSM_CAM_IOCTL_CSID_IO_CFG failed\n", __func__);
+  if(csi_obj->mode_3d) {
+	cfg_cnt = 2;
   }
+  
+  for (i=0; i<cfg_cnt; i++) {  
+  	cfg.core_index = i;
+  	cfg.cfgtype = CSID_INIT;
+  	rc = ioctl(csi_obj->fd, MSM_CAM_IOCTL_CSID_IO_CFG, &cfg);
+  	if (rc < 0) {
+    	CDBG_ERROR("%s MSM_CAM_IOCTL_CSID_IO_CFG failed\n", __func__);
+  	}
 
-  CDBG("%s csid_version = %x\n", __func__, cfg.cfg.csid_version);
-  *csid_version = cfg.cfg.csid_version;
-
+  	CDBG("%s csid_version = %x\n", __func__, cfg.cfg.csid_version);
+  	*csid_version = cfg.cfg.csid_version;
+  }
   return rc;
 }
 
@@ -38,22 +46,68 @@ int csid_process_init(csi_t *csi_obj, uint32_t *csid_version)
  *
  * DESCRIPTION:
  *==========================================================*/
+extern void sensor_dump_csi_params(sensor_csi_params_t  *csi_param);
 int csid_set_cfg(csi_t *csi_obj, enum msm_sensor_resolution_t res)
 {
   int rc = 0;
+  int i =0;
+  int cfg_cnt=1;
   struct csid_cfg_data cfg;
+  int not_null = 0;
+  struct csi_lane_params_t *csi_lane_params = NULL;
+  int index=0;
+
+  if(csi_obj->mode_3d) {
+	cfg_cnt = 2;
+  }
+
+  for (i=0; i<cfg_cnt; i++) { 
+	  CDBG("%s csi_params for csi%d:\n",__func__, i);
+	 sensor_dump_csi_params(csi_obj->csi3d_params[i]);
+  }
+
+  for (i=0; i<cfg_cnt; i++) {  
+  	CDBG("%s called for csi%d\n", __func__, i);
+    if(csi_obj->mode_3d) {
+  	    CDBG("%s 3d mode csi%d\n", __func__, i);
+        
+  	not_null = (csi_obj->csi3d_params[i]) ?1:0;
+  	    CDBG("%s csi3d_params%d not_null (%d)\n", __func__, i, not_null);
+    /*not_null = (csi_obj->csi3d_params[i]->csi_lane_params)?1:0;
+  	    CDBG("%s csi3d_params%d_lane not_null (%d)\n", __func__, i, not_null);*/
+  	not_null = (csi_obj->csi3d_params[i]->csi2_params)?1:0;
+  	    CDBG("%s csi3d_params%d csi2 not_null (%d) (%p)\n", __func__, i, not_null, csi_obj->csi3d_params[i]->csi2_params);
+  	not_null = (csi_obj->csi3d_params[i]->csi2_params[res])?1:0;
+  	    CDBG("%s csi3d_params%d csi2 res not_null (%d) (%p)\n", __func__, i, not_null, csi_obj->csi3d_params[i]->csi2_params[res]);
+  	/*not_null = (csi_obj->csi3d_params[i]->csi2_params[res]->csid_params)?1:0;
+  	 CDBG("%s csi3d_params%d csi2_csid not_null (%d)\n", __func__, i, not_null);*/
+
+  		csi_obj->csi3d_params[i]->csi2_params[res]->csid_params.lane_assign =
+    		csi_obj->csi3d_params[i]->csi_lane_params.csi_lane_assign;
+  		csi_obj->csi3d_params[i]->csi2_params[res]->csid_params.phy_sel =
+    		csi_obj->csi3d_params[i]->csi_lane_params.csi_phy_sel;
+	} else {
+  		csi_obj->csi_params->csi2_params[res]->csid_params.lane_assign =
+    		csi_obj->csi_params->csi_lane_params.csi_lane_assign;
+  		csi_obj->csi_params->csi2_params[res]->csid_params.phy_sel =
+    		csi_obj->csi_params->csi_lane_params.csi_phy_sel;
+	}
 
-  csi_obj->csi_params->csi2_params[res]->csid_params.lane_assign =
-    csi_obj->csi_params->csi_lane_params.csi_lane_assign;
-  csi_obj->csi_params->csi2_params[res]->csid_params.phy_sel =
-    csi_obj->csi_params->csi_lane_params.csi_phy_sel;
-
-  cfg.cfgtype = CSID_CFG;
-  cfg.cfg.csid_params =
-    &csi_obj->csi_params->csi2_params[res]->csid_params;
-  rc = ioctl(csi_obj->fd, MSM_CAM_IOCTL_CSID_IO_CFG, &cfg);
-  if (rc < 0) {
-    CDBG_ERROR("%s MSM_CAM_IOCTL_CSID_IO_CFG failed\n", __func__);
+  	cfg.core_index = i;
+  	cfg.cfgtype = CSID_CFG;
+    if(csi_obj->mode_3d) {
+  	    CDBG("%s csi3d_params%d cfg assignment\n", __func__, i);
+  		cfg.cfg.csid_params =
+    		&csi_obj->csi3d_params[i]->csi2_params[res]->csid_params;
+	} else {
+  		cfg.cfg.csid_params =
+    		&csi_obj->csi_params->csi2_params[res]->csid_params;
+	}
+  	    CDBG("%s csi3d_params%d ioctl\n", __func__, i);
+  	rc = ioctl(csi_obj->fd, MSM_CAM_IOCTL_CSID_IO_CFG, &cfg);
+  	if (rc < 0) {
+    	CDBG_ERROR("%s MSM_CAM_IOCTL_CSID_IO_CFG failed\n", __func__);
+  	}
   }
 
   return rc;
diff --git a/server/hardware/csi/csi2/csiphy/csiphy.c b/server/hardware/csi/csi2/csiphy/csiphy.c
index e64e2a8..d2e97b4 100644
--- a/server/hardware/csi/csi2/csiphy/csiphy.c
+++ b/server/hardware/csi/csi2/csiphy/csiphy.c
@@ -18,16 +18,26 @@
 int csiphy_process_init(csi_t *csi_obj)
 {
   int rc = 0;
+  int i =0;
+  int cfg_cnt=1;
   struct csiphy_cfg_data cfg;
 
-  CDBG("%s called\n", __func__);
-
-  cfg.cfgtype = CSIPHY_INIT;
-  rc = ioctl(csi_obj->fd, MSM_CAM_IOCTL_CSIPHY_IO_CFG, &cfg);
-  if (rc < 0) {
-    CDBG_ERROR("%s MSM_CAM_IOCTL_CSIPHY_IO_CFG failed\n", __func__);
+  if(csi_obj->mode_3d) {
+	cfg_cnt = 2;
   }
 
+  for (i=0; i<cfg_cnt; i++) {  
+
+  	CDBG("%s called for csi%d\n", __func__, i);
+
+  	cfg.core_index = i;
+  	cfg.cfgtype = CSIPHY_INIT;
+  	rc = ioctl(csi_obj->fd, MSM_CAM_IOCTL_CSIPHY_IO_CFG, &cfg);
+  	if (rc < 0) {
+    	CDBG_ERROR("%s MSM_CAM_IOCTL_CSIPHY_IO_CFG failed\n", __func__);
+		break;
+  	}
+  }
   return rc;
 }
 
@@ -39,20 +49,42 @@ int csiphy_process_init(csi_t *csi_obj)
 int csiphy_set_cfg(csi_t *csi_obj, enum msm_sensor_resolution_t res)
 {
   int rc = 0;
+  int i =0;
+  int cfg_cnt=1;
   struct csiphy_cfg_data cfg;
 
-  csi_obj->csi_params->csi2_params[res]->csiphy_params.lane_mask =
-    csi_obj->csi_params->csi_lane_params.csi_lane_mask;
+  if(csi_obj->mode_3d) {
+	cfg_cnt = 2;
+  }
 
-  CDBG("%s csi2_params = %p\n", __func__,
-    csi_obj->csi_params->csi2_params[res]);
+  for (i=0; i<cfg_cnt; i++) {  
+  	CDBG("%s called for csi%d\n", __func__, i);
 
-  cfg.cfgtype = CSIPHY_CFG;
-  cfg.csiphy_params = &csi_obj->csi_params->csi2_params[res]->csiphy_params;
-  rc = ioctl(csi_obj->fd, MSM_CAM_IOCTL_CSIPHY_IO_CFG, &cfg);
-  if (rc < 0) {
-    CDBG_ERROR("%s MSM_CAM_IOCTL_CSIPHY_IO_CFG failed\n", __func__);
-  }
+  	if(csi_obj->mode_3d) {
+  		csi_obj->csi3d_params[i]->csi2_params[res]->csiphy_params.lane_mask =
+    		csi_obj->csi3d_params[i]->csi_lane_params.csi_lane_mask;
+  		CDBG("%s csi2_params%d = %p\n", __func__, i, 
+    		csi_obj->csi3d_params[i]->csi2_params[res]);
+	} else {
+  		csi_obj->csi_params->csi2_params[res]->csiphy_params.lane_mask =
+    		csi_obj->csi_params->csi_lane_params.csi_lane_mask;
+  		CDBG("%s csi2_params = %p\n", __func__,
+    		csi_obj->csi_params->csi2_params[res]);
+	}
 
+
+	cfg.core_index=i;
+  	cfg.cfgtype = CSIPHY_CFG;
+  	if(csi_obj->mode_3d) {
+  		cfg.csiphy_params = &csi_obj->csi3d_params[i]->csi2_params[res]->csiphy_params;
+	} else {
+  		cfg.csiphy_params = &csi_obj->csi_params->csi2_params[res]->csiphy_params;
+	}
+  	rc = ioctl(csi_obj->fd, MSM_CAM_IOCTL_CSIPHY_IO_CFG, &cfg);
+  	if (rc < 0) {
+    	CDBG_ERROR("%s MSM_CAM_IOCTL_CSIPHY_IO_CFG failed\n", __func__);
+        break;  
+  	}
+  }
   return rc;
 }
diff --git a/server/hardware/csi/csi_interface.c b/server/hardware/csi/csi_interface.c
index bcbdbb4..8e94268 100644
--- a/server/hardware/csi/csi_interface.c
+++ b/server/hardware/csi/csi_interface.c
@@ -108,6 +108,7 @@ static int csi_client_get_params(uint32_t handle, int type, void *parm,
  *
  * DESCRIPTION:
  *==========================================================*/
+extern void sensor_dump_csi_params(sensor_csi_params_t  *csi_param);
 static int csi_client_set_params(uint32_t handle, int type, void *parm_in,
   void *parm_out)
 {
@@ -130,10 +131,32 @@ static int csi_client_set_params(uint32_t handle, int type, void *parm_in,
 
   switch(type) {
   case CSI_SET_DATA:
-    csi_client->csi_ctrl_obj.csi_params = csi_set->data.csi_params;
-    CDBG("%s in, out csi_params = %p, %p\n", __func__,
-      csi_set->data.csi_params,
-      csi_client->csi_ctrl_obj.csi_params);
+	if(csi_set->mode_3d) {
+		int i = 0;
+    	csi_client->csi_ctrl_obj.csi3d_params[0] = csi_set->data.csi3d_params[0];
+    	csi_client->csi_ctrl_obj.csi3d_params[1] = csi_set->data.csi3d_params[1];
+    	csi_client->csi_ctrl_obj.mode_3d = 1; 
+    	CDBG("%s in, out csi_params0 = %p, %p\n", __func__,
+      		csi_set->data.csi3d_params[0],
+      		csi_client->csi_ctrl_obj.csi3d_params[0]);
+    	CDBG("%s in, out csi_params1 = %p, %p\n", __func__,
+      		csi_set->data.csi3d_params[1],
+      		csi_client->csi_ctrl_obj.csi3d_params[1]);
+  		for (i=0; i<2; i++) { 
+	  		CDBG("%s csi_params from csi_set csi%d:\n",__func__, i);
+	    	sensor_dump_csi_params(csi_set->data.csi3d_params[i]);
+		}	
+  		for (i=0; i<2; i++) { 
+	  		CDBG("%s csi_params to csi_obj csi%d:\n",__func__, i);
+	    	sensor_dump_csi_params(csi_client->csi_ctrl_obj.csi3d_params[i]);
+		}	
+	} else {
+    	csi_client->csi_ctrl_obj.csi_params = csi_set->data.csi_params;
+    	csi_client->csi_ctrl_obj.mode_3d = 0; 
+    	CDBG("%s in, out csi_params = %p, %p\n", __func__,
+      		csi_set->data.csi_params,
+      		csi_client->csi_ctrl_obj.csi_params);
+	}
     break;
 
   case CSI_SET_CFG:
diff --git a/server/hardware/csi/csi_interface.h b/server/hardware/csi/csi_interface.h
index fe49ef1..351c21a 100644
--- a/server/hardware/csi/csi_interface.h
+++ b/server/hardware/csi/csi_interface.h
@@ -22,10 +22,12 @@ typedef enum {
 typedef union {
   enum msm_sensor_resolution_t res;
   sensor_csi_params_t *csi_params;
+  sensor_csi_params_t *csi3d_params[2];
 } csi_set_data_t;
 
 typedef struct {
   csi_set_data_t data;
+  uint8_t mode_3d;
 } csi_set_t;
 
 /********************************
diff --git a/server/hardware/eeprom/eeprom.c b/server/hardware/eeprom/eeprom.c
index b3b0877..fdace68 100644
--- a/server/hardware/eeprom/eeprom.c
+++ b/server/hardware/eeprom/eeprom.c
@@ -441,10 +441,13 @@ void eeprom_init(eeprom_ctrl_t *ectrl)
        ectrl->cali_data = eeprom_calib_data.raw.data;
        eeprom_get_data(ectrl, eeprom_calib_info.raw.index);
        CDBG("%s raw data size %d\n", __func__, eeprom_calib_data.raw.size);
+       CDBG("%s DEBUG: suppressing printing of eeprom data...\n", __func__);
+	#if 0
        for (index = 0; index < eeprom_calib_data.raw.size; index++) {
          CDBG("%s raw data[%d] %x\n", __func__, index,
            eeprom_calib_data.raw.data[index]);
        }
+	#endif
     } else {
        CDBG_ERROR("%s:%d malloc failed\n", __func__, __LINE__);
        eeprom_calib_info.raw.is_supported = 0;
diff --git a/server/hardware/ispif/ispif.c b/server/hardware/ispif/ispif.c
index e1588a4..5ce7132 100644
--- a/server/hardware/ispif/ispif.c
+++ b/server/hardware/ispif/ispif.c
@@ -124,10 +124,16 @@ int ispif_process_cfg(ispif_client_t *ispif_client,
     cfg.cfg.ispif_params.params[index++] =
       ispif_obj->ispif_ctrl[i].ispif_params;
     ispif_obj->ispif_ctrl[i].pending = 0;
+    if(ispif_obj->ispif_ctrl[i].output_param.is3D) {
+  		cfg.cfg.ispif_params.output_param.is3D = 1;
+  		cfg.cfg.ispif_params.output_param.x_output_size = 
+			ispif_obj->ispif_ctrl[i].output_param.x_output_size;
+	}
   }
   if (!index)
     return rc;
 
+ 
   cfg.cfg.ispif_params.len = index;
   rc = ioctl(ispif_client->ops->fd, MSM_CAM_IOCTL_ISPIF_IO_CFG, &cfg);
   if (rc < 0)
diff --git a/server/hardware/ispif/ispif.h b/server/hardware/ispif/ispif.h
index 796a085..64bc878 100644
--- a/server/hardware/ispif/ispif.h
+++ b/server/hardware/ispif/ispif.h
@@ -18,6 +18,7 @@ typedef struct {
   uint8_t client_idx;
   uint8_t used;
   struct msm_ispif_params ispif_params;
+  struct msm_ispif_output_params output_param;
   uint8_t pending;
 } ispif_ctrl_t;
 
diff --git a/server/hardware/ispif/ispif_interface.c b/server/hardware/ispif/ispif_interface.c
index b90df66..e523fc7 100755
--- a/server/hardware/ispif/ispif_interface.c
+++ b/server/hardware/ispif/ispif_interface.c
@@ -11,6 +11,8 @@
 
 static ispif_comp_root_t my_ispif_struct;
 
+#define CAMERA_3D_MODE 1
+
 #if ISPIF_DEBUG
 #undef CDBG
 #define CDBG LOGE
@@ -277,6 +279,12 @@ static int ispif_client_set_params(uint32_t handle, int type, void *parm_in,
         ispif_obj->ispif_ctrl[PIX0].client_idx = 0;
         isBayer = 0;
         break;
+      case PIX_1:
+        CDBG("%s, in PIX_1",__func__);
+        ispif_obj->ispif_ctrl[PIX1].used = 0;
+        ispif_obj->ispif_ctrl[PIX1].client_idx = 0;
+        isBayer = 0;
+        break;
       case RDI_0:
         CDBG("%s, in RDI_0",__func__);
         ispif_obj->ispif_ctrl[RDI0].used = 0;
@@ -399,13 +407,23 @@ if( !isBayer )
       ispif_client->channel_stream_info = STREAM_RAW_AND_RAW;
       break;
 #if 1 // QCT 10092012 - Rear Camera Recording through C2D
-        case STREAM_IMAGE:
+      case STREAM_IMAGE:
           if (ispif_obj->ispif_ctrl[PIX0].used == 0) {
 	    CDBG("%s: Configuring PIX 0", __func__);
             ispif_params_list.params[len++].intftype = PIX0;
             ispif_client->channel_interface_mask |= PIX_0;
             ispif_client->channel_stream_info = STREAM_IMAGE;
           }
+	  if(sensor_get.data.mode_3d){
+        CDBG("%s, ispif_client config sensor in 3d mode",__func__);
+	    CDBG("%s: Configuring 3D mode PIX 1", __func__);
+          if (ispif_obj->ispif_ctrl[PIX1].used == 0) {
+	    CDBG("%s: Configuring PIX 1", __func__);
+            ispif_params_list.params[len++].intftype = PIX1;
+            ispif_client->channel_interface_mask |= PIX_1;
+            ispif_client->channel_stream_info = STREAM_IMAGE;
+          }
+	  }
       break;
     default:
       break;
@@ -435,12 +453,31 @@ if( !isBayer )
 
     ispif_client->stream_mask = ispif_client->channel_interface_mask;
 
-    CDBG_ERROR("%s, Lenght: %d",__func__, len);
+    CDBG_ERROR("%s, Length: %d",__func__, len);
     for (i = 0; i < len; i++) {
       CDBG_ERROR("%s, i: %d, InterfaceType: %d", __func__, i, ispif_params_list.params[i].intftype);
       intftype = ispif_params_list.params[i].intftype;
       ispif_obj->ispif_ctrl[intftype].ispif_params.intftype = intftype;
+
+	if(sensor_get.data.mode_3d){
+      CDBG_ERROR("%s, ispif_params config sensor in 3d mode",__func__);
+      /*ispif_obj->ispif_ctrl[intftype].ispif_params.csid = sensor_get.data.sensor_csi3d_params[i]->csi_lane_params.csid_core[0];*/
+      if (intftype == PIX0) {
+		ispif_obj->ispif_ctrl[intftype].ispif_params.csid = 
+			sensor_get.data.sensor_csi3d_params[1]->csi_lane_params.csid_core[0];
+	  	/* configure 3d output params */
+      	ispif_obj->ispif_ctrl[intftype].output_param.is3D = 1; 
+      	ispif_obj->ispif_ctrl[intftype].output_param.x_output_size = 0x668;
+	  }
+      else if (intftype == PIX1)
+		ispif_obj->ispif_ctrl[intftype].ispif_params.csid = 
+			sensor_get.data.sensor_csi3d_params[0]->csi_lane_params.csid_core[0];
+	} else {
+      CDBG_ERROR("%s, ispif_params config sensor in non-3d mode",__func__);
       ispif_obj->ispif_ctrl[intftype].ispif_params.csid = sensor_get.data.sensor_csi_params->csi_lane_params.csid_core[0];
+      	ispif_obj->ispif_ctrl[intftype].output_param.is3D = 0; 
+      	ispif_obj->ispif_ctrl[intftype].output_param.x_output_size = 0;
+	}
 #if 1 // QCT 10092012 - Rear Camera Recording through C2D
      if (intftype == RDI0)
         ispif_obj->ispif_ctrl[intftype].ispif_params.cid_mask =
@@ -458,11 +495,15 @@ if( !isBayer )
 #endif
       else if (intftype == PIX0)
         ispif_obj->ispif_ctrl[intftype].ispif_params.cid_mask = (1 << 0);
+      else if (intftype == PIX1)
+        ispif_obj->ispif_ctrl[intftype].ispif_params.cid_mask = (1 << 0);
+
       ispif_obj->ispif_ctrl[intftype].ispif_params.vfe_intf = ispif_set->data.vfe_interface;
       ispif_obj->ispif_ctrl[intftype].client_idx = ispif_client->client_idx;
       if (intf_mask != ispif_client->channel_interface_mask)
         ispif_obj->ispif_ctrl[intftype].pending = 1;
       ispif_obj->ispif_ctrl[intftype].used = 1;
+
 	   CDBG_ERROR("%s, Inft typ: %d, CID_mask: %d; VFE interface: %d, CSID: %d, Used: %d",__func__, ispif_obj->ispif_ctrl[i].ispif_params.intftype,ispif_obj->ispif_ctrl[intftype].ispif_params.cid_mask, ispif_obj->ispif_ctrl[intftype].ispif_params.vfe_intf, ispif_obj->ispif_ctrl[intftype].ispif_params.csid,ispif_obj->ispif_ctrl[intftype].used);
     }
 #else
@@ -483,7 +524,6 @@ if( !isBayer )
     rc = -EINVAL;
     break;
   }
-  CDBG_ERROR("%s, Inft typ: %d, CID_mask: %d; VFE interface: %d, CSID: %d, Used: %d",__func__, ispif_obj->ispif_ctrl[PIX0].ispif_params.intftype,ispif_obj->ispif_ctrl[PIX0].ispif_params.cid_mask, ispif_obj->ispif_ctrl[PIX0].ispif_params.vfe_intf, ispif_obj->ispif_ctrl[PIX0].ispif_params.csid,ispif_obj->ispif_ctrl[PIX0].used);
 
   pthread_mutex_unlock(&my_ispif_struct.mutex);
 
diff --git a/server/hardware/sensor/sensor.h b/server/hardware/sensor/sensor.h
index 5423589..f525260 100644
--- a/server/hardware/sensor/sensor.h
+++ b/server/hardware/sensor/sensor.h
@@ -166,6 +166,7 @@ typedef struct {
   char **sensor_load_chromatixfile;
   sensor_crop_parms_t *crop_info;
   sensor_csi_params_t sensor_csi_params;
+  sensor_csi_params_t sensor_csi3d_params[2];
   uint32_t *mode_res;
   int32_t num_res;
   uint32_t pending_fps;
@@ -173,6 +174,7 @@ typedef struct {
   int32_t cur_frame_length_lines;
   int32_t cur_line_length_pclk;
   int8_t is_vision_mode;
+  uint8_t mode_3d;
 
   sensor_data_t out_data;
 } sensor_params_t;
diff --git a/server/hardware/sensor/sensor_interface.c b/server/hardware/sensor/sensor_interface.c
index f3ced91..783d9f5 100644
--- a/server/hardware/sensor/sensor_interface.c
+++ b/server/hardware/sensor/sensor_interface.c
@@ -286,6 +286,7 @@ static int  sensor_client_set_params(uint32_t handle, int type,
  *
  * DESCRIPTION:
  *==========================================================================*/
+extern void sensor_dump_csi_params(sensor_csi_params_t  *csi_param);
 static int sensor_client_get_params(uint32_t handle, int type,
                                     void *parm, int parm_len)
 {
@@ -361,9 +362,30 @@ static int sensor_client_get_params(uint32_t handle, int type,
   case SENSOR_GET_CSI_PARAMS:
     if(sctrl->fn_table->sensor_get_csi_params)
       sctrl->fn_table->sensor_get_csi_params(sctrl);
-    sensor_get->data.sensor_csi_params = &sctrl->sensor.sensor_csi_params;
-    CDBG("%s sensor_csi_params = %p\n", __func__,
-      sensor_get->data.sensor_csi_params);
+    if(&sctrl->sensor.mode_3d) {
+		int i =0;
+		sensor_get->data.mode_3d = 1;
+    	sensor_get->data.sensor_csi3d_params[0] = &sctrl->sensor.sensor_csi3d_params[0];
+    	sensor_get->data.sensor_csi3d_params[1] = &sctrl->sensor.sensor_csi3d_params[1];
+    	CDBG("%s sensor_csi3d_params0 = %p\n", __func__,
+      		sensor_get->data.sensor_csi3d_params[0]);
+    	CDBG("%s sensor_csi3d_params1 = %p\n", __func__,
+      		sensor_get->data.sensor_csi3d_params[1]);
+  		for (i=0; i<2; i++) { 
+	  		CDBG("%s csi_params from sensor csi%d:\n",__func__, i);
+	    	sensor_dump_csi_params(&sctrl->sensor.sensor_csi3d_params[i]);
+		}	
+  		for (i=0; i<2; i++) { 
+	  		CDBG("%s csi_params copied to sensor_get csi%d:\n",__func__, i);
+	    	sensor_dump_csi_params(sensor_get->data.sensor_csi3d_params[i]);
+		}	
+	}
+	else {
+        sensor_get->data.mode_3d = 0;
+    	sensor_get->data.sensor_csi_params = &sctrl->sensor.sensor_csi_params;
+    	CDBG("%s sensor_csi_params = %p\n", __func__,
+      		sensor_get->data.sensor_csi_params);
+	}
     break;
   case SENSOR_GET_LENS_INFO:
     if (!sctrl->fn_table->sensor_get_lens_info)
diff --git a/server/hardware/sensor/sensor_util.c b/server/hardware/sensor/sensor_util.c
index 87d19af..c21212a 100644
--- a/server/hardware/sensor/sensor_util.c
+++ b/server/hardware/sensor/sensor_util.c
@@ -156,6 +156,7 @@ int8_t sensor_util_get_output_info(void *sctrl)
 {
   struct sensor_cfg_data cfg;
   int index = 0;
+  int i=0;
   sensor_ctrl_t *ctrl = (sensor_ctrl_t *) sctrl;
   if (ctrl->sfd <= 0) {
     CDBG_ERROR("%s failed %d\n", __func__, __LINE__);
@@ -187,6 +188,13 @@ int8_t sensor_util_get_output_info(void *sctrl)
          ctrl->sensor.output_info[index].binning_factor);
   }
 
+  if (ctrl->sensor.mode_3d == 1) {
+    CDBG("%s: 3D mode: double x_output on all res\n", __func__);
+  /*if ((ctrl->support_3d == 1) && (ctrl->sensor.cam_mode == CAMERA_MODE_3D)) {*/
+    for (i = 0; i < ctrl->sensor.num_res; i++) {
+      ctrl->sensor.output_info[i].x_output *= 2;
+    }
+  }
   CDBG("%s exit\n", __func__);
   return 0;
 }
@@ -665,3 +673,19 @@ int8_t sensor_util_get_csi_params(void *sctrl)
   CDBG("%s exit\n", __func__);
   return TRUE;
 }
+
+void sensor_dump_csi_params(sensor_csi_params_t  *csi_param) {
+	struct csi_lane_params_t *csi_lane_params = NULL;
+	int index = 0;
+	int count = 0;
+
+	CDBG("%s: csi_params (%p)\n", __func__, csi_param);
+	  csi_lane_params = &csi_param->csi_lane_params;
+	  CDBG("%s csi lane params, lane assign = 0x%x, lane mask = 0x%x, csi = %d\n",
+    		__func__, csi_lane_params->csi_lane_assign, csi_lane_params->csi_lane_mask,
+		    csi_lane_params->csi_if);
+	  count = (csi_lane_params->csi_if > 10) ? 10 : csi_lane_params->csi_if;
+      for (index = 0; index < count; index ++)
+      		CDBG("%s csi_lane_params, csid_core[%d] = %d\n", __func__,
+        	index, csi_lane_params->csid_core[index]);
+}
diff --git a/server/hardware/vfe/vfe_modules/rolloff/pca_rolloff.c b/server/hardware/vfe/vfe_modules/rolloff/pca_rolloff.c
index 152aee4..e75cf48 100644
--- a/server/hardware/vfe/vfe_modules/rolloff/pca_rolloff.c
+++ b/server/hardware/vfe/vfe_modules/rolloff/pca_rolloff.c
@@ -263,12 +263,16 @@ static void pca_rolloff_mesh_table_debug(mesh_rolloff_array_type *meshtbl)
 {
   int i = 6 * 17;
   int nummax = 8 * 17 - 1;
+
+  CDBG("%s suppressing table dump debug prints...\n", __func__);
+#if 0
   //MESH_ROLLOFF_SIZE
   for (i = 0; i < MESH_ROLLOFF_SIZE; i++) {
     CDBG("%s: i=%d, r : %f, gr : %f, gb : %f, b : %f\n", __func__, i,
     meshtbl->r_gain[i], meshtbl->gr_gain[i],
     meshtbl->gb_gain[i], meshtbl->b_gain[i]);
   }
+#endif
   return;
 } /* pca_rolloff_mesh_table_debug */
 
diff --git a/server/include/intf_comm_data.h b/server/include/intf_comm_data.h
index e803e4c..55bd47b 100644
--- a/server/include/intf_comm_data.h
+++ b/server/include/intf_comm_data.h
@@ -245,6 +245,7 @@ typedef struct {
   sensor_aec_data_t aec_info;
   uint32_t fps;
   sensor_csi_params_t *sensor_csi_params;
+  sensor_csi_params_t *sensor_csi3d_params[2];
   enum msm_sensor_resolution_t cur_res;
   uint32_t get_pending_fps;
   sensor_mode_t op_mode;
@@ -253,6 +254,7 @@ typedef struct {
   sensor_lens_info_t lens_info;
   uint32_t pxlcode;
   uint32_t videohdr_mode;
+  uint8_t mode_3d;
 } sensor_data_t;
 
  typedef struct {
