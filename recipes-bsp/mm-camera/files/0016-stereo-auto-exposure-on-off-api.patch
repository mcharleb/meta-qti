diff --git a/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.c b/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.c
index 66af6e7..aa1726d 100644
--- a/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.c
+++ b/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.c
@@ -3205,12 +3205,51 @@ int v4l2_qcamlib_set_aec_exposure_value(int32_t ev_abs) {
 	return set_EV(ev_abs); 
 }
 
+static int v4l2_qcamlib_set_aec(int enable) {
+  struct v4l2_queryctrl queryctrl;
+  struct v4l2_control control;
+  uint32_t val = enable ? 0x1101 : 0x1100;
+
+  memset (&queryctrl, 0, sizeof (queryctrl));
+  queryctrl.id = V4L2_CID_EXPOSURE;
+
+  if (-1 == ioctl (camfd, VIDIOC_QUERYCTRL, &queryctrl)) {
+    if (errno != EINVAL) {
+      perror ("VIDIOC_QUERYCTRL");
+	  return -1;
+    } else {
+      printf ("V4L2_CID_EXPOSURE is not supported\n");
+	  return -1;
+    }
+  } else if (queryctrl.flags & V4L2_CTRL_FLAG_DISABLED) {
+      printf ("V4L2_CID_EXPOSURE is Disabled \n");
+	  return -1;
+  } else {
+
+    memset (&control, 0, sizeof (control));
+    control.id = V4L2_CID_EXPOSURE;
+    control.value = val;
+    if (-1 == ioctl (camfd, VIDIOC_S_CTRL, &control)) {
+      perror ("VIDIOC_S_CTRL");
+      return -1;
+    }
+  }
+}
+
+int v4l2_qcamlib_disable_aec() {
+	return v4l2_qcamlib_set_aec(0);
+}
+
+int v4l2_qcamlib_enable_aec() {
+	return v4l2_qcamlib_set_aec(1);
+}
+
 int v4l2_qcamlib_set_exposure_manual(v4l2_qcamlib_sensor_aec_t* aec_data) {
   struct v4l2_queryctrl queryctrl;
   struct v4l2_control control;
 
   memset (&queryctrl, 0, sizeof (queryctrl));
-  queryctrl.id = MSM_V4L2_PID_BL_DETECTION;
+  queryctrl.id = V4L2_CID_EXPOSURE;
 
   if (-1 == ioctl (camfd, VIDIOC_QUERYCTRL, &queryctrl)) {
     if (errno != EINVAL) {
@@ -3376,6 +3415,7 @@ int v4l2_qcamlib_set_auto_focus_mode (int af_mode)
   struct v4l2_queryctrl queryctrl;
   struct v4l2_control control;
 
+#if 0
   memset (&queryctrl, 0, sizeof (queryctrl));
   queryctrl.id = MSM_V4L2_PID_FOCUS_MODE;
 
@@ -3389,6 +3429,7 @@ int v4l2_qcamlib_set_auto_focus_mode (int af_mode)
   } else if (queryctrl.flags & V4L2_CTRL_FLAG_DISABLED) {
       printf ("V4L2_CID_FOCUS_ABSOLUTE is not supported\n");
   } else {
+#endif
     memset (&control, 0, sizeof (control));
     control.id = MSM_V4L2_PID_FOCUS_MODE;
     control.value = af_mode;
@@ -3397,7 +3438,9 @@ int v4l2_qcamlib_set_auto_focus_mode (int af_mode)
       perror ("VIDIOC_S_CTRL");
       return -1;
     }
+#if 0
   }
+#endif
   return 0;
 }
 
diff --git a/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.h b/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.h
index 216cc0a..fd49169 100644
--- a/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.h
+++ b/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.h
@@ -46,6 +46,9 @@ typedef struct {
 } v4l2_qcamlib_sensor_aec_t;
 
 int v4l2_qcamlib_set_exposure_manual(v4l2_qcamlib_sensor_aec_t* aec_data); 
+int v4l2_qcamlib_disable_aec();
+int v4l2_qcamlib_enable_aec();
+
 
 /* Camera Resolution Control */
 #define SQCIF_WIDTH     128
diff --git a/apps/v4l2-qcamera-app/v4l2-qcamera-app.c b/apps/v4l2-qcamera-app/v4l2-qcamera-app.c
index b19e019..134f66a 100644
--- a/apps/v4l2-qcamera-app/v4l2-qcamera-app.c
+++ b/apps/v4l2-qcamera-app/v4l2-qcamera-app.c
@@ -1758,6 +1758,13 @@ void print_all_preview_video_resolutions() {
 		printf("\t\t: %d : %s\n", resoln, v4l2_qcamlib_get_preview_video_resolution_description(resoln));
 }
 
+typedef enum {
+	AEC_SET_DISABLE = 0,
+	AEC_SET_ENABLE,
+	AEC_SET_DONE
+} aec_set_status_t;
+
+int set_aec = AEC_SET_DONE;
 int manual_exposure_set = 0;
 int preview_dimensions = 0;
 uint16_t preview_width = 0;
@@ -1783,8 +1790,11 @@ int main(int argc, char **argv)
 #endif
 
   /* get v4l2 params - memory type etc */
-  while ((c = getopt(argc, argv, "mouhfiqd:e:r:s:t:")) != -1) {
+  while ((c = getopt(argc, argv, "mouhfiqd:e:r:s:t:a:")) != -1) {
     switch (c) {
+      case 'a':
+        set_aec = atoi(optarg);
+        break;
       case 'd':
         yuvFrameDumpFactor = atoi(optarg);
         break;
@@ -1849,6 +1859,9 @@ int main(int argc, char **argv)
         printf("-d <factor> :   Dump Frames with factor  \n");
         printf("            :   <n>: Dump mod(n) frames  \n");
         printf("            :   <1>: Dump all frames  \n");
+        printf("-a <n>      :   Enable/Disable AEC  \n");
+        printf("            :   <0>: Disable  \n");
+        printf("            :   <1>: Enable  \n");
         printf("-m          :   Manual exposure control  \n");
         printf("-s <width>  :   Set Preview/Video frame width  \n");
         printf("-t <height> :   Set Preview/Video frame height  \n");
@@ -2258,6 +2271,18 @@ void test_v4l2_preview_cb_fn(void* src_vb) {
 	if(manual_exposure_set)
 	dummy_exposure_control(frameCntp);
 
+	if(frameCntp == 100) {
+		if(set_aec == AEC_SET_DISABLE) {
+			CDBG_ERROR("Disabling AEC\n");
+			v4l2_qcamlib_disable_aec();
+			set_aec = AEC_SET_DONE;
+		} else if(set_aec == AEC_SET_ENABLE) {
+			CDBG_ERROR("Enabling AEC\n");
+			v4l2_qcamlib_enable_aec();
+			set_aec = AEC_SET_DONE;
+		}
+	}
+
 	if(frameCntp == 500)
 	v4l2_qcamlib_set_auto_focus_mode(4); /*(AF_MODE_INFINITY);*/
 
diff --git a/server/core/config/config_proc_ctrlcmd.c b/server/core/config/config_proc_ctrlcmd.c
index 358034e..0177c61 100644
--- a/server/core/config/config_proc_ctrlcmd.c
+++ b/server/core/config/config_proc_ctrlcmd.c
@@ -834,26 +834,41 @@ static int8_t config_proc_CAMERA_SET_PARM_EXPOSURE_MANUAL(void *parm1, void *par
   /*stats_proc_ctrl_t *sp_ctrl = &(ctrl->stats_proc_ctrl);*/
   struct msm_ctrl_cmd *ccmd = (struct msm_ctrl_cmd *)parm2;
   uint32_t value = *(uint32_t *)ccmd->value;
-  if(value != 0x0101) {
-  	CDBG_ERROR("%s Skipping.. \n", __func__);
-	return TRUE;
-  }
-	
-  CDBG("%s:%d] manual lum %d gain %f linecnt %u"
+
+  sensor_set_t set_param;
+
+  if (value == 0x1100) {
+  	/* Auto Exposure Disable */
+    set_param.type = SENSOR_SET_EXPOSURE_AUTO_ON_OFF;
+  	rc = ctrl->comp_ops[MCTL_COMPID_SENSOR].set_params(
+         ctrl->comp_ops[MCTL_COMPID_SENSOR].handle,
+         SENSOR_SET_EXPOSURE_AUTO_ON_OFF, NULL, NULL);
+  } else if (value == 0x1101) {
+  	/* Auto Exposure Enable */
+    set_param.type = SENSOR_SET_EXPOSURE_AUTO_ON_OFF;
+  	rc = ctrl->comp_ops[MCTL_COMPID_SENSOR].set_params(
+         ctrl->comp_ops[MCTL_COMPID_SENSOR].handle,
+         SENSOR_SET_EXPOSURE_AUTO_ON_OFF, (void*)&set_param, NULL);
+  } else if(value == 0x0101) {
+  	CDBG("%s:%d] manual lum %d gain %f linecnt %u"
         " luma target %d ", __func__, __LINE__,
         aec_data.current_luma,
         aec_data.gain,
         aec_data.linecount,
         aec_data.luma_target);
 
-  sensor_set_t set_param;
-  set_param.type = SENSOR_SET_EXPOSURE;
-  set_param.data.aec_data = aec_data;
+  	set_param.type = SENSOR_SET_EXPOSURE;
+  	set_param.data.aec_data = aec_data;
 
-  rc = ctrl->comp_ops[MCTL_COMPID_SENSOR].set_params(
+  	rc = ctrl->comp_ops[MCTL_COMPID_SENSOR].set_params(
          ctrl->comp_ops[MCTL_COMPID_SENSOR].handle,
          SENSOR_SET_EXPOSURE, (void *)&set_param, NULL);
 
+  } else {
+  	CDBG_ERROR("%s Skipping.. \n", __func__);
+	return TRUE;
+  }
+	
   ccmd->status = rc ? CAM_CTRL_SUCCESS : CAM_CTRL_FAILED;
   if (rc < 0)
         CDBG_ERROR("%s FAILED to set Exposure values manually\n", __func__);
diff --git a/server/hardware/sensor/sensor_interface.c b/server/hardware/sensor/sensor_interface.c
index 655893c..fe55b03 100644
--- a/server/hardware/sensor/sensor_interface.c
+++ b/server/hardware/sensor/sensor_interface.c
@@ -92,6 +92,7 @@ static int sensor_client_init(uint32_t handle, mctl_ops_t *ops,
  *
  * DESCRIPTION:
  *==========================================================================*/
+static int disable_auto_exposure = 1;
 static int  sensor_client_set_params(uint32_t handle, int type,
   void *parm_in, void *parm_out)
 {
@@ -161,14 +162,29 @@ static int  sensor_client_set_params(uint32_t handle, int type,
       sctrl->sensor.pending_fps = 0;
     }
     break;
+  case SENSOR_SET_EXPOSURE_AUTO_ON_OFF: {
+    if (NULL == sensor_set) {
+		disable_auto_exposure = 1;
+        CDBG_ERROR("%s:%d] SENSOR_SET_EXPOSURE Disable AEC \n",
+			 __func__, __LINE__);
+	}
+	else {
+		disable_auto_exposure = 0;
+        CDBG_ERROR("%s:%d] SENSOR_SET_EXPOSURE Enable AEC \n",
+			 __func__, __LINE__);
+	}
+    }
+	break;
   case SENSOR_SET_EXPOSURE: {
     /* get exposure settings from stats proc */
     sensor_set_aec_data_t aec_data;
     if (NULL == sensor_set) {
 
+	  if(disable_auto_exposure) {
       /*CDBG_ERROR("%s:%d] SENSOR_SET_EXPOSURE thru aec skipping \n",
 			 __func__, __LINE__);*/
       return 1;
+	  }
 	
       stats_proc_get_t stats_proc_get;
       stats_proc_get.d.get_aec.type = AEC_EXPOSURE_PARAMS;
@@ -188,13 +204,14 @@ static int  sensor_client_set_params(uint32_t handle, int type,
       aec_data.luma_target =
         stats_proc_get.d.get_aec.d.exp_params.luma_target;
       aec_data.skip_snap_wait = 0;
-      CDBG("%s:%d] SENSOR_SET_EXPOSURE snap %d lum %d gain %f linecnt %u"
+      CDBG_ERROR("%s:%d] SENSOR_SET_EXPOSURE snap %d lum %d gain %f linecnt %u"
         " luma target %d \n", __func__, __LINE__,
         stats_proc_get.d.get_aec.d.exp_params.is_snapshot,
         aec_data.current_luma,
         aec_data.gain,
         aec_data.linecount,
         aec_data.luma_target);
+
     } else {
       aec_data = sensor_set->data.aec_data;
       CDBG_ERROR("%s:%d] SENSOR_SET_EXPOSURE manual lum %d gain %f linecnt %u"
diff --git a/server/hardware/sensor/sensor_interface.h b/server/hardware/sensor/sensor_interface.h
index 38349f0..844fae7 100644
--- a/server/hardware/sensor/sensor_interface.h
+++ b/server/hardware/sensor/sensor_interface.h
@@ -36,6 +36,7 @@ typedef enum {
   SENSOR_SET_LP_RES_TABLE,
   SENSOR_SET_HDR_AWB,
   SENSOR_SET_HDR_LSC,
+  SENSOR_SET_EXPOSURE_AUTO_ON_OFF,
 } sensor_set_type_t;
 
 
