diff --git a/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.c b/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.c
index aa1726d..eba2a1e 100644
--- a/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.c
+++ b/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.c
@@ -1768,6 +1768,22 @@ int check_snapshot_formats_supported(void)
   return -1;
 }
 
+uint32_t enable_csi_swap = 1;
+
+static int v4l2_qcamlib_set_camera_hardware_type_internal() {
+  int rc = 0;
+  struct v4l2_control ctrl;
+
+  CDBG_ERROR("%s enable_csi_swap(%d)\n", __func__, enable_csi_swap); 
+  ctrl.id = MSM_V4L2_PID_SNOW_DETECTION;
+  ctrl.value = enable_csi_swap;
+  rc = ioctl(camfd, VIDIOC_S_CTRL, &ctrl);
+
+  if(rc < 0)
+	CDBG_ERROR("%s, IOCTL VIDIOC_S_CTRL failed \n", __func__);	
+  return rc;
+}
+
 /*===========================================================================
  * FUNCTION    - system_video_init -
  *
@@ -1855,6 +1871,8 @@ int system_init()
     return rc;
   }
 
+  v4l2_qcamlib_set_camera_hardware_type_internal(); 
+
   /* Re-set input_display size to video size */
   input_display.user_input_display_width = dimension->video_width;
   input_display.user_input_display_height = dimension->video_height;
@@ -2438,13 +2456,15 @@ int v4l2_qcamlib_start_preview()
   test_v4l2_preview_callback_init();
 #endif
 
-  CDBG("%s: system_init\n", __func__);
+
   if (system_init() < 0)
     return -1; 
-  CDBG("%s: start_video\n", __func__);
+
+  CDBG_ERROR("%s: start_video\n", __func__);
   if (start_video() != 0) {
     return -1; 
   }
+
   /* Because the config thread doesn't have a lot of control information until video is started,
    * query controls here */
   v4l2_queryctrls();
@@ -3410,6 +3430,23 @@ cam_format_t v4l2_qcamlib_get_preview_frame_format() {
 	return usr_prev_format;
 }
 
+int v4l2_qcamlib_set_camera_hardware_type(camera_type_t camera_hw) {
+  struct v4l2_control ctrl;
+
+  if(camera_hw == CAMERA_BYKUGAN) {
+    CDBG_ERROR("%s Setting camera hardware as bykugan (%d)\n", __func__, camera_hw); 
+	enable_csi_swap = 1;
+  } else if(camera_hw == CAMERA_WIDE_EYE) {
+    CDBG_ERROR("%s Setting camera hardware as WideEye (%d)\n", __func__, camera_hw); 
+	enable_csi_swap = 0;
+  } else {
+	  CDBG_ERROR("%s, Invalid camera hardware (%d)\n", __func__, camera_hw);	
+	  return -1;
+  }
+
+  return 0;
+}
+
 int v4l2_qcamlib_set_auto_focus_mode (int af_mode)
 {
   struct v4l2_queryctrl queryctrl;
@@ -3434,7 +3471,7 @@ int v4l2_qcamlib_set_auto_focus_mode (int af_mode)
     control.id = MSM_V4L2_PID_FOCUS_MODE;
     control.value = af_mode;
 
-    if (-1 == ioctl (camfd, VIDIOC_S_CTRL, &control)) {
+    if (-1 == ioctl (eventfd, VIDIOC_S_CTRL, &control)) {
       perror ("VIDIOC_S_CTRL");
       return -1;
     }
diff --git a/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.h b/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.h
index fd49169..30372d5 100644
--- a/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.h
+++ b/apps/v4l2-qcamera-app/v4l2-qcamera-app-lib.h
@@ -139,3 +139,11 @@ typedef enum {
 /* Set Auto Focus mode */
 int v4l2_qcamlib_set_auto_focus_mode (int af_mode);
 
+typedef enum {
+	CAMERA_BYKUGAN = 0,
+	CAMERA_WIDE_EYE,
+} camera_type_t;
+
+int v4l2_qcamlib_set_camera_hardware_type(camera_type_t camera_hw);
+
+
diff --git a/apps/v4l2-qcamera-app/v4l2-qcamera-app.c b/apps/v4l2-qcamera-app/v4l2-qcamera-app.c
index 134f66a..faeb5d4 100644
--- a/apps/v4l2-qcamera-app/v4l2-qcamera-app.c
+++ b/apps/v4l2-qcamera-app/v4l2-qcamera-app.c
@@ -1764,6 +1764,7 @@ typedef enum {
 	AEC_SET_DONE
 } aec_set_status_t;
 
+int set_camera_type = -1;
 int set_aec = AEC_SET_DONE;
 int manual_exposure_set = 0;
 int preview_dimensions = 0;
@@ -1790,11 +1791,14 @@ int main(int argc, char **argv)
 #endif
 
   /* get v4l2 params - memory type etc */
-  while ((c = getopt(argc, argv, "mouhfiqd:e:r:s:t:a:")) != -1) {
+  while ((c = getopt(argc, argv, "mouhfiqd:e:r:s:t:a:c:")) != -1) {
     switch (c) {
       case 'a':
         set_aec = atoi(optarg);
         break;
+      case 'c':
+        set_camera_type = atoi(optarg);
+        break;
       case 'd':
         yuvFrameDumpFactor = atoi(optarg);
         break;
@@ -1802,7 +1806,7 @@ int main(int argc, char **argv)
         v4l2_qcamlib_enable_display_overlay(); 
         break;
       case 'e':
-        /*v4l2_qcamlib_set_exposure_value(atoi(optarg)); */
+        v4l2_qcamlib_set_aec_exposure_value(atoi(optarg)); 
         break;
       case 'm':
         manual_exposure_set = 1;
@@ -1854,13 +1858,16 @@ int main(int argc, char **argv)
       case 'h':
       default:
         printf("usage: %s [] \n", argv[0]);
+        printf("-c <type>   :   Set Camera type \n");
+        printf("            :   <0>: Bykugan (Default) \n");
+        printf("            :   <1>: WideEye  \n");
         printf("-o          :   Enable display overlay \n");
         /*printf("-e <factor> :   Set Exposure Value < -12 to 12 >  \n");*/
         printf("-d <factor> :   Dump Frames with factor  \n");
         printf("            :   <n>: Dump mod(n) frames  \n");
         printf("            :   <1>: Dump all frames  \n");
         printf("-a <n>      :   Enable/Disable AEC  \n");
-        printf("            :   <0>: Disable  \n");
+        printf("            :   <0>: Disable (Default) \n");
         printf("            :   <1>: Enable  \n");
         printf("-m          :   Manual exposure control  \n");
         printf("-s <width>  :   Set Preview/Video frame width  \n");
@@ -1921,6 +1928,10 @@ static int submain()
   struct timezone tz;*/
 
   test_v4l2_preview_callback_init();
+
+  if(set_camera_type != -1)
+	v4l2_qcamlib_set_camera_hardware_type(set_camera_type);
+	
   rc = v4l2_qcamlib_start_preview();
   if(rc < 0) goto ERROR;
 
@@ -2270,7 +2281,7 @@ void test_v4l2_preview_cb_fn(void* src_vb) {
 	/* Test exposure control api */
 	if(manual_exposure_set)
 	dummy_exposure_control(frameCntp);
-
+  
 	if(frameCntp == 100) {
 		if(set_aec == AEC_SET_DISABLE) {
 			CDBG_ERROR("Disabling AEC\n");
diff --git a/server/core/config/config_proc_ctrlcmd.c b/server/core/config/config_proc_ctrlcmd.c
index 0177c61..9286a6c 100644
--- a/server/core/config/config_proc_ctrlcmd.c
+++ b/server/core/config/config_proc_ctrlcmd.c
@@ -2944,6 +2944,33 @@ static int8_t config_proc_CAMERA_SET_FLIP_HINT(void *parm1, void *parm2)
   return rc;
 }
 
+/*===========================================================================
+ * FUNCTION    - config_proc_CAMERA_SET_CHANNEL_STREAM -
+ *
+ * DESCRIPTION:
+ *==========================================================================*/
+static int8_t config_proc_CAMERA_SET_ISPIF_PARAM_HW(void *parm1, void *parm2)
+{
+  int8_t rc = TRUE;
+  mctl_config_ctrl_t *ctrl = (mctl_config_ctrl_t *)parm1;
+  struct msm_ctrl_cmd *ctrlCmd = (struct msm_ctrl_cmd *)parm2;
+  uint32_t  enable_csi_swap = *((uint32_t *)ctrlCmd->value);
+  ctrlCmd->status = CAM_CTRL_SUCCESS;
+    ispif_set_t ispif_set;
+    CDBG_ERROR("%s csi_swap:%d\n", __func__, enable_csi_swap);
+    memset(&ispif_set, 0, sizeof(ispif_set));
+    ispif_set.data.output_port_info = enable_csi_swap;
+    rc = ctrl->comp_ops[MCTL_COMPID_ISPIF].set_params(
+      ctrl->comp_ops[MCTL_COMPID_ISPIF].handle,
+      ISPIF_SET_INTF_PARAMS_HW, &ispif_set, NULL);
+    if (rc < 0) {
+      CDBG_ERROR("%s: ispif_set_params failed %d\n", __func__, rc);
+      ctrlCmd->status = CAM_CTRL_FAILED;
+      return FALSE;
+    }
+
+	return TRUE;
+}
 
 /*===========================================================================
  * FUNCTION    - config_proc_CAMERA_SET_CHANNEL_STREAM -
@@ -5645,11 +5672,18 @@ int config_proc_set_ctrl_cmd(void *parm1, void *parm2, int *cmdPending)
       ctrlCmd->status = ret;
       break;
 
+	/* Set Auto Focus mode */
     case MSM_V4L2_PID_FOCUS_MODE:
       *(int *)ctrlCmd->value = v4l2_ctrl->value;
       ret = config_proc_CAMERA_SET_PARM_AF_MODE(ctrl, ctrlCmd);
       ctrlCmd->status = ret;
       break;
+	/* Set HW specific ISPIF param */
+    case MSM_V4L2_PID_SNOW_DETECTION:
+      *(int *)ctrlCmd->value = v4l2_ctrl->value;
+      ret = config_proc_CAMERA_SET_ISPIF_PARAM_HW(ctrl, ctrlCmd);
+      ctrlCmd->status = ret;
+      break;
     default: {
         ret = TRUE;
         ctrlCmd->status = CAM_CTRL_SUCCESS;
diff --git a/server/hardware/ispif/ispif_interface.c b/server/hardware/ispif/ispif_interface.c
index e523fc7..020cf64 100755
--- a/server/hardware/ispif/ispif_interface.c
+++ b/server/hardware/ispif/ispif_interface.c
@@ -182,6 +182,7 @@ static int ispif_client_get_params(uint32_t handle, int parm_type,
  *
  * DESCRIPTION:
  *==========================================================*/
+uint8_t enable_csi_swap = 1;
 static int ispif_client_set_params(uint32_t handle, int type, void *parm_in,
   void *parm_out)
 {
@@ -247,6 +248,16 @@ static int ispif_client_set_params(uint32_t handle, int type, void *parm_in,
       }
     }
     break;
+  case ISPIF_SET_INTF_PARAMS_HW: {
+	if(ispif_set->data.output_port_info == 1) {
+		enable_csi_swap = 1;
+		CDBG_ERROR("%s, Enable CSI Swap \n", __func__);
+	} else {
+		enable_csi_swap = 0;
+		CDBG_ERROR("%s, Disable CSI Swap \n", __func__);
+	}
+	break;
+	}
   case ISPIF_SET_INTF_PARAMS: {
     sensor_get_t sensor_get;
     int intftype;
@@ -462,16 +473,24 @@ if( !isBayer )
 	if(sensor_get.data.mode_3d){
       CDBG_ERROR("%s, ispif_params config sensor in 3d mode",__func__);
       /*ispif_obj->ispif_ctrl[intftype].ispif_params.csid = sensor_get.data.sensor_csi3d_params[i]->csi_lane_params.csid_core[0];*/
+	  uint32_t pix_0_val = 0;
+	  uint32_t pix_1_val = 1;
+
+	  if(enable_csi_swap) {
+		pix_0_val = 1;
+		pix_1_val = 0;
+	  }
+
       if (intftype == PIX0) {
 		ispif_obj->ispif_ctrl[intftype].ispif_params.csid = 
-			sensor_get.data.sensor_csi3d_params[1]->csi_lane_params.csid_core[0];
+			sensor_get.data.sensor_csi3d_params[pix_0_val]->csi_lane_params.csid_core[0];
 	  	/* configure 3d output params */
       	ispif_obj->ispif_ctrl[intftype].output_param.is3D = 1; 
       	ispif_obj->ispif_ctrl[intftype].output_param.x_output_size = 0x668;
 	  }
       else if (intftype == PIX1)
 		ispif_obj->ispif_ctrl[intftype].ispif_params.csid = 
-			sensor_get.data.sensor_csi3d_params[0]->csi_lane_params.csid_core[0];
+			sensor_get.data.sensor_csi3d_params[pix_1_val]->csi_lane_params.csid_core[0];
 	} else {
       CDBG_ERROR("%s, ispif_params config sensor in non-3d mode",__func__);
       ispif_obj->ispif_ctrl[intftype].ispif_params.csid = sensor_get.data.sensor_csi_params->csi_lane_params.csid_core[0];
diff --git a/server/hardware/ispif/ispif_interface.h b/server/hardware/ispif/ispif_interface.h
index 10e08ea..6fff46c 100644
--- a/server/hardware/ispif/ispif_interface.h
+++ b/server/hardware/ispif/ispif_interface.h
@@ -21,6 +21,7 @@ typedef enum {
   ISPIF_PROCESS_STOP_IMMEDIATELY,
   ISPIF_PROCESS_RELEASE,
   ISPIF_PARM_ADD_OBJ_ID,
+  ISPIF_SET_INTF_PARAMS_HW,
   ISPIF_MAX_NUM
 } ispif_params_type_t;
 
